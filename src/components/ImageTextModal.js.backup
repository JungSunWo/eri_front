'use client';

import { Link, X } from 'lucide-react';
import { useCallback, useEffect, useRef, useState } from 'react';

/**
 * 이미지에 텍스트를 추가하는 모달 컴포넌트
 *
 * @param {Object} props
 * @param {boolean} props.isOpen - 모달 열림/닫힘 상태
 * @param {Function} props.onClose - 모달 닫기 함수
 * @param {File} props.imageFile - 텍스트를 추가할 이미지 파일
 * @param {Function} props.onConfirm - 텍스트 추가 완료 시 호출되는 함수 (processedImageFile을 매개변수로 받음)
 * @param {Object} props.defaultOptions - 기본 텍스트 옵션
 */
export default function ImageTextModal({
  isOpen,
  onClose,
  imageFile,
  onConfirm,
  defaultOptions = {}
}) {
  // 대표글 배열 (여러 개의 대표글을 관리)
  const [mainTexts, setMainTexts] = useState([]);

  // 현재 편집 중인 대표글
  const [currentMainText, setCurrentMainText] = useState({
    text: '',
    fontSize: 24,
    color: '#ffffff',
    strokeColor: '#000000',
    position: 'bottom',
    customX: null,
    customY: null,
    id: null
  });

  // 링크 배열
  const [links, setLinks] = useState([]);

  // links 상태 변경 감지
  useEffect(() => {
    console.log('links 상태 변경됨:', links);
    console.log('links 길이:', links.length);
  }, [links]);

  // mainTexts 상태 변경 감지
  useEffect(() => {
    console.log('mainTexts 상태 변경됨:', mainTexts);
    console.log('mainTexts 길이:', mainTexts.length);
  }, [mainTexts]);

  const [currentLink, setCurrentLink] = useState({
    url: '',
    text: '',
    position: null
  });

  // 대표글 기본 옵션
  const [mainTextOptions, setMainTextOptions] = useState({
    fontSize: 24,
    color: '#ffffff',
    strokeColor: '#000000',
    position: 'bottom',
    ...defaultOptions
  });

  // 링크 기본 옵션
  const [linkOptions, setLinkOptions] = useState({
    fontSize: 20,
    color: '#0066cc',
    strokeColor: '#000000',
    underline: true,
    ...defaultOptions
  });
  const [previewUrl, setPreviewUrl] = useState('');
  const [isDragging, setIsDragging] = useState(false);
  const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
  const [draggedLinkId, setDraggedLinkId] = useState(null);
  const canvasRef = useRef(null);
  const imageRef = useRef(null);
  const previewContainerRef = useRef(null);
  const updatePreviewRef = useRef(null);

  // 이미지 로드 및 미리보기 생성
  useEffect(() => {
    if (imageFile && canvasRef.current) {
      const img = new Image();
      img.onload = () => {
        imageRef.current = img;
        // updatePreview 함수가 정의된 후에만 호출
        if (updatePreviewRef.current) {
          updatePreviewRef.current();
        }
      };
      img.src = URL.createObjectURL(imageFile);
    }
  }, [imageFile]);

  // 텍스트나 옵션 변경 시 미리보기 업데이트
  useEffect(() => {
    if (imageRef.current && updatePreviewRef.current) {
      updatePreviewRef.current();
    }
  }, [mainTexts, mainTextOptions, links, linkOptions]);

  // 모달이 열릴 때 상태 초기화
  useEffect(() => {
    if (isOpen && imageFile) {
      console.log('모달 열림 - 상태 초기화');
      // 모달이 열릴 때 상태 초기화
      setMainTexts([]);
      setLinks([]);
      setCurrentMainText({
        text: '',
        fontSize: 24,
        color: '#ffffff',
        strokeColor: '#000000',
        position: 'bottom',
        customX: null,
        customY: null,
        id: null
      });
      setCurrentLink({ url: '', text: '', position: null });
      setMainTextOptions({
        fontSize: 24,
        color: '#ffffff',
        strokeColor: '#000000',
        position: 'bottom',
        ...defaultOptions
      });
      setPreviewUrl('');
      setIsDragging(false);
      setDraggedLinkId(null);
      setDragOffset({ x: 0, y: 0 });
    }
  }, [isOpen, imageFile]); // defaultOptions 제거

  // 드래그 시작
  const handleMouseDown = (e) => {
    if (!previewContainerRef.current) return;

    const rect = previewContainerRef.current.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    const img = imageRef.current;
    if (!img) return;

    const scaleX = img.width / rect.width;
    const scaleY = img.height / rect.height;

    // 링크 드래그 확인
    for (let i = links.length - 1; i >= 0; i--) {
      const link = links[i];
      if (link.position) {
        const linkX = link.position.x / scaleX;
        const linkY = link.position.y / scaleY;
        const linkWidth = link.position.width / scaleX;
        const linkHeight = link.position.height / scaleY;

        if (Math.abs(x - linkX) < linkWidth / 2 + 10 &&
            Math.abs(y - linkY) < linkHeight / 2 + 10) {
          setIsDragging(true);
          setDraggedLinkId(link.id);
          setDragOffset({
            x: x - linkX,
            y: y - linkY
          });
          return;
        }
      }
    }

    // 대표글 드래그 확인 (각 대표글을 개별적으로 확인)
    for (let i = mainTexts.length - 1; i >= 0; i--) {
      const mainText = mainTexts[i];
      if (mainText.customX !== null && mainText.customY !== null) {
        const textX = mainText.customX / scaleX;
        const textY = mainText.customY / scaleY;
        const fontSize = mainText.fontSize / scaleY;

        // 대표글 텍스트 너비 계산
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        ctx.font = `${mainText.fontSize}px Arial, sans-serif`;
        const textWidth = ctx.measureText(mainText.text).width / scaleX;

        if (Math.abs(x - textX) < textWidth / 2 + 20 &&
            Math.abs(y - textY) < fontSize + 20) {
          setIsDragging(true);
          setDraggedLinkId(`mainText_${mainText.id}`);
          setDragOffset({
            x: x - textX,
            y: y - textY
          });
          return;
        }
      }
    }
  };

  // 드래그 중
  const handleMouseMove = (e) => {
    if (!isDragging || !previewContainerRef.current || !imageRef.current) return;

    const rect = previewContainerRef.current.getBoundingClientRect();
    const x = e.clientX - rect.left - dragOffset.x;
    const y = e.clientY - rect.top - dragOffset.y;

    const img = imageRef.current;
    const scaleX = img.width / rect.width;
    const scaleY = img.height / rect.height;

    // 이미지 경계 내로 제한
    const newX = Math.max(0, Math.min(img.width, x * scaleX));
    const newY = Math.max(0, Math.min(img.height, y * scaleY));

    if (draggedLinkId && draggedLinkId.startsWith('mainText_')) {
      // 대표글 드래그
      const mainTextId = draggedLinkId.replace('mainText_', '');
      setMainTexts(prev => prev.map(mainText =>
        mainText.id === mainTextId
          ? { ...mainText, customX: newX, customY: newY }
          : mainText
      ));
    } else if (draggedLinkId) {
      // 링크 드래그
      setLinks(prev => prev.map(link =>
        link.id === draggedLinkId
          ? { ...link, position: { ...link.position, x: newX, y: newY } }
          : link
      ));
    }
  };

  // 드래그 종료
  const handleMouseUp = () => {
    setIsDragging(false);
    setDraggedLinkId(null);
  };

  // 텍스트 너비 계산
  const getTextWidth = useCallback(() => {
    if (!imageRef.current) return 0;

    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    ctx.font = `${mainTextOptions.fontSize}px Arial, sans-serif`;

    // 현재 편집 중인 대표글 텍스트 사용
    const words = currentMainText.text.split(' ');
    let maxWidth = 0;

    words.forEach(word => {
      const width = ctx.measureText(word).width;
      maxWidth = Math.max(maxWidth, width);
    });

    return maxWidth;
  }, [currentMainText.text, mainTextOptions.fontSize]);

  // 링크 텍스트 너비 계산
  const getLinkTextWidth = useCallback((text, fontSize = linkOptions.fontSize) => {
    if (!imageRef.current) return 0;

    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    ctx.font = `${fontSize}px Arial, sans-serif`;

    return ctx.measureText(text).width;
  }, [linkOptions.fontSize]);

  // 기본 Y 위치 계산
  const getDefaultY = useCallback(() => {
    if (!imageRef.current) return 0;

    const img = imageRef.current;
    const { fontSize, position } = mainTextOptions;

    switch (position) {
      case 'top':
        return fontSize + 20;
      case 'center':
        return img.height / 2;
      case 'bottom':
        return img.height - 20;
      default:
        return img.height - 20;
    }
  }, [mainTextOptions.fontSize, mainTextOptions.position]);

  // URL 유효성 검사
  const isValidUrl = (string) => {
    try {
      new URL(string);
      return true;
    } catch (_) {
      return false;
    }
  };

  // 링크 추가
  const addLink = () => {
    console.log('addLink 호출됨');
    console.log('currentLink:', currentLink);
    console.log('currentLink.url:', currentLink.url);
    console.log('currentLink.text:', currentLink.text);
    console.log('isValidUrl(currentLink.url):', isValidUrl(currentLink.url));

    if (!currentLink.url.trim() || !isValidUrl(currentLink.url)) {
      console.log('URL 유효성 검사 실패');
      alert('유효한 URL을 입력해주세요.');
      return;
    }

    if (!currentLink.text.trim()) {
      console.log('링크 텍스트 검사 실패');
      alert('링크 텍스트를 입력해주세요.');
      return;
    }

    // 이미지 참조 확인
    const img = imageRef.current;
    if (!img) {
      alert('이미지를 불러오는 중입니다. 잠시 후 다시 시도해주세요.');
      return;
    }

    // 링크 위치 계산 - 기존 링크들과 겹치지 않도록 조정
    let x, y;
    const existingLinks = links || [];

    // 기본 시작 위치 (메인 텍스트와 겹치지 않도록)
    let baseX, baseY;
    if (mainTextOptions.customX !== null && mainTextOptions.customY !== null) {
      // 메인 텍스트가 커스텀 위치에 있는 경우
      baseX = mainTextOptions.customX + 50;
      baseY = mainTextOptions.customY + 30;
    } else {
      // 기본 위치 계산
      baseX = img.width / 2 + 50; // 메인 텍스트보다 오른쪽으로
      baseY = getDefaultY() + 30; // 메인 텍스트보다 아래로
    }

    // 기존 링크들과 겹치지 않는 위치 찾기
    let offsetX = 0;
    let offsetY = 0;
    let attempts = 0;
    const maxAttempts = 20;

    do {
      x = baseX + offsetX;
      y = baseY + offsetY;

      // 이미지 경계 내로 제한
      x = Math.max(50, Math.min(img.width - 50, x));
      y = Math.max(30, Math.min(img.height - 30, y));

      // 기존 링크들과 겹치는지 확인
      const overlaps = existingLinks.some(link => {
        const linkX = link.position.x;
        const linkY = link.position.y;
        const linkWidth = link.position.width;
        const linkHeight = link.position.height;

        // 간단한 사각형 겹침 검사
        return !(x + 10 < linkX || x > linkX + linkWidth + 10 ||
                y + 5 < linkY || y > linkY + linkHeight + 5);
      });

      if (!overlaps) break;

      // 겹치면 위치를 조정
      offsetX += 20;
      if (offsetX > 200) {
        offsetX = 0;
        offsetY += 25;
      }

      attempts++;
    } while (attempts < maxAttempts);

    // 최대 시도 횟수를 초과하면 마지막 위치 사용
    if (attempts >= maxAttempts) {
      x = baseX + 200;
      y = baseY + 100;
      x = Math.max(50, Math.min(img.width - 50, x));
      y = Math.max(30, Math.min(img.height - 30, y));
    }

    const linkTextWidth = getLinkTextWidth(currentLink.text, linkOptions.fontSize);
    const linkTextHeight = linkOptions.fontSize;

    const newLink = {
      id: `link_${Date.now()}`,
      url: currentLink.url,
      text: currentLink.text,
      position: {
        x: x,
        y: y,
        width: linkTextWidth,
        height: linkTextHeight
      },
      style: {
        fontSize: linkOptions.fontSize,
        color: linkOptions.color,
        strokeColor: linkOptions.strokeColor,
        underline: linkOptions.underline
      }
    };

        setLinks(prev => {
      const newLinks = [...prev, newLink];
      console.log('링크 추가됨:', newLink);
      console.log('현재 링크 목록:', newLinks);
      console.log('링크 개수:', newLinks.length);
      return newLinks;
    });
    setCurrentLink({ url: '', text: '', position: null });

    // 성공 메시지 (선택사항)
    // alert('링크가 성공적으로 추가되었습니다!');
  };

  // 대표글 추가
  const addMainText = () => {
    if (!currentMainText.text.trim()) {
      alert('대표글을 입력해주세요.');
      return;
    }

    const img = imageRef.current;
    if (!img) {
      alert('이미지를 불러오는 중입니다. 잠시 후 다시 시도해주세요.');
      return;
    }

    // 대표글 위치 계산
    let x, y;
    if (currentMainText.customX !== null && currentMainText.customY !== null) {
      x = currentMainText.customX;
      y = currentMainText.customY;
    } else {
      x = img.width / 2;
      // 선택된 위치에 따라 Y 좌표 결정
      switch (currentMainText.position) {
        case 'top':
          y = currentMainText.fontSize + 20;
          break;
        case 'center':
          y = img.height / 2;
          break;
        case 'bottom':
          y = img.height - 20;
          break;
        case 'custom':
        default:
          y = img.height / 2; // 기본값은 중앙
          break;
      }
    }

    // 커스텀 위치로 설정 (드래그 가능하도록)
    const customX = x;
    const customY = y;

          const newMainText = {
        id: `mainText_${Date.now()}`,
        text: currentMainText.text,
        fontSize: currentMainText.fontSize,
        color: currentMainText.color,
        strokeColor: currentMainText.strokeColor,
        position: currentMainText.position,
        customX: customX,
        customY: customY
      };

    setMainTexts(prev => {
      const newMainTexts = [...prev, newMainText];
      console.log('대표글 추가됨:', newMainText);
      console.log('현재 대표글 목록:', newMainTexts);
      console.log('대표글 개수:', newMainTexts.length);
      return newMainTexts;
    });

    // 현재 편집 중인 대표글 초기화
    setCurrentMainText({
      text: '',
      fontSize: mainTextOptions.fontSize,
      color: mainTextOptions.color,
      strokeColor: mainTextOptions.strokeColor,
      position: mainTextOptions.position,
      customX: null,
      customY: null,
      id: null
    });
  };

  // 대표글 삭제
  const removeMainText = (mainTextId) => {
    setMainTexts(prev => prev.filter(mainText => mainText.id !== mainTextId));
  };

  // 링크 삭제
  const removeLink = (linkId) => {
    setLinks(prev => prev.filter(link => link.id !== linkId));
  };

  // 미리보기 업데이트 함수
  const updatePreview = useCallback(() => {
    if (!imageRef.current || !canvasRef.current) return;

    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    const img = imageRef.current;

    // 캔버스 크기 설정
    canvas.width = img.width;
    canvas.height = img.height;

    // 이미지 그리기
    ctx.drawImage(img, 0, 0);

    // 대표글 그리기
    mainTexts.forEach((mainText, index) => {
      if (mainText.text) {
        const {
          fontSize,
          color,
          strokeColor,
          position,
          customX,
          customY
        } = mainText;

        // X, Y 좌표 결정 (커스텀 위치 우선)
        let x, y;
        if (customX !== null && customY !== null) {
          x = customX;
          y = customY;
        } else {
          x = img.width / 2;
          // 선택된 위치에 따라 Y 좌표 결정
          switch (position) {
            case 'top':
              y = fontSize + 20;
              break;
            case 'center':
              y = img.height / 2;
              break;
            case 'bottom':
              y = img.height - 20;
              break;
            case 'custom':
            default:
              y = img.height / 2; // 기본값은 중앙
              break;
          }
        }

        const maxWidth = img.width * 0.8;

        ctx.font = `${fontSize}px Arial, sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = position === 'top' ? 'top' :
                          position === 'center' ? 'middle' : 'bottom';

        // 텍스트 줄바꿈 처리 (엔터키와 공백 모두 인식)
        const lines = [];
        const paragraphs = mainText.text.split('\n'); // 엔터키로 문단 분리

        paragraphs.forEach(paragraph => {
          if (paragraph.trim() === '') {
            // 빈 줄은 그대로 추가
            lines.push('');
            return;
          }

          const words = paragraph.split(' ');
          let currentLine = words[0] || '';

          for (let i = 1; i < words.length; i++) {
            const word = words[i];
            const width = ctx.measureText(currentLine + ' ' + word).width;
            if (width < maxWidth) {
              currentLine += ' ' + word;
            } else {
              lines.push(currentLine);
              currentLine = word;
            }
          }
          if (currentLine) {
            lines.push(currentLine);
          }
        });

        // 각 줄에 텍스트 그리기
        lines.forEach((line, lineIndex) => {
          const lineY = y + (lineIndex - (lines.length - 1) / 2) * (fontSize + 5);

          // 텍스트 외곽선 (그림자 효과)
          ctx.strokeStyle = strokeColor;
          ctx.lineWidth = 2;
          ctx.strokeText(line, x, lineY);

          // 텍스트 그리기
          ctx.fillStyle = color;
          ctx.fillText(line, x, lineY);
        });

        // 대표글 영역 표시
        ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
        ctx.lineWidth = 1;
        ctx.setLineDash([3, 3]);
        ctx.strokeRect(
          x - maxWidth / 2 - 10,
          y - fontSize / 2 - 10,
          maxWidth + 20,
          fontSize * lines.length + 20
        );
        ctx.setLineDash([]);

        // 대표글 번호 표시
        ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
        ctx.font = '12px Arial, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(`대표글 ${index + 1}`, x, y - fontSize / 2 - 20);
      }
    });

    // 링크 텍스트 그리기
    links.forEach((link, index) => {
      if (link.position && link.text) {
        const x = link.position.x;
        const y = link.position.y;

        // 링크별 스타일 적용
        const linkStyle = link.style || linkOptions;
        const fontSize = linkStyle.fontSize || linkOptions.fontSize;
        const color = linkStyle.color || linkOptions.color;
        const strokeColor = linkStyle.strokeColor || linkOptions.strokeColor;
        const underline = linkStyle.underline !== undefined ? linkStyle.underline : linkOptions.underline;

        // 링크 텍스트 그리기
        ctx.font = `${fontSize}px Arial, sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        // 텍스트 외곽선
        ctx.strokeStyle = strokeColor;
        ctx.lineWidth = 3;
        ctx.strokeText(link.text, x, y);

        // 링크 텍스트
        ctx.fillStyle = color;
        ctx.fillText(link.text, x, y);

        // 링크 밑줄
        if (underline) {
          const textWidth = ctx.measureText(link.text).width;
          ctx.strokeStyle = color;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x - textWidth / 2, y + fontSize / 2 + 3);
          ctx.lineTo(x + textWidth / 2, y + fontSize / 2 + 3);
          ctx.stroke();
        }

        // 링크 영역 표시 (더 명확하게)
        ctx.strokeStyle = 'rgba(0, 102, 204, 0.7)';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.strokeRect(
          x - link.position.width / 2 - 5,
          y - link.position.height / 2 - 5,
          link.position.width + 10,
          link.position.height + 10
        );
        ctx.setLineDash([]);

        // 링크 번호 표시
        ctx.fillStyle = 'rgba(0, 102, 204, 0.8)';
        ctx.font = '12px Arial, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(`${index + 1}`, x, y - link.position.height / 2 - 10);
      }
    });

    // 현재 입력 중인 링크 미리보기 (링크 텍스트가 있고 위치가 계산된 경우)
    if (currentLink.text && currentLink.position) {
      const x = currentLink.position.x;
      const y = currentLink.position.y;
      const fontSize = linkOptions.fontSize;
      const color = linkOptions.color;
      const strokeColor = linkOptions.strokeColor;

      ctx.font = `${fontSize}px Arial, sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      // 텍스트 외곽선
      ctx.strokeStyle = strokeColor;
      ctx.lineWidth = 3;
      ctx.strokeText(currentLink.text, x, y);

      // 링크 텍스트
      ctx.fillStyle = color;
      ctx.fillText(currentLink.text, x, y);

      // 링크 밑줄
      if (linkOptions.underline) {
        const textWidth = ctx.measureText(currentLink.text).width;
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x - textWidth / 2, y + fontSize / 2 + 3);
        ctx.lineTo(x + textWidth / 2, y + fontSize / 2 + 3);
        ctx.stroke();
      }

      // 현재 링크 영역 표시 (점선으로 구분)
      ctx.strokeStyle = 'rgba(255, 0, 0, 0.7)';
      ctx.lineWidth = 2;
      ctx.setLineDash([3, 3]);
      ctx.strokeRect(
        x - getLinkTextWidth(currentLink.text, fontSize) / 2 - 5,
        y - fontSize / 2 - 5,
        getLinkTextWidth(currentLink.text, fontSize) + 10,
        fontSize + 10
      );
      ctx.setLineDash([]);
    }

    // 캔버스를 URL로 변환하여 미리보기 업데이트
    setPreviewUrl(canvas.toDataURL());
  }, [mainTexts, mainTextOptions, links, linkOptions, currentLink, getDefaultY]);

  // updatePreview 함수를 ref에 할당
  updatePreviewRef.current = updatePreview;

  // 위치 초기화
  const resetPosition = () => {
    setMainTextOptions(prev => ({
      ...prev,
      customX: null,
      customY: null,
      position: 'bottom'
    }));
  };

  // 이미지에 텍스트와 링크 추가 함수 (최종 처리용)
  const addTextToImage = (imageFile, mainTexts = [], options = {}, links = []) => {
    return new Promise((resolve, reject) => {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const img = new Image();

      img.onload = () => {
        // 캔버스 크기를 이미지 크기로 설정
        canvas.width = img.width;
        canvas.height = img.height;

        // 이미지 그리기
        ctx.drawImage(img, 0, 0);

        // 텍스트 스타일 설정
        const {
          fontSize = Math.max(img.width, img.height) * 0.05, // 이미지 크기의 5%
          fontFamily = 'Arial, sans-serif',
          color = '#ffffff',
          strokeColor = '#000000',
          strokeWidth = 2,
          position = 'bottom', // 'top', 'center', 'bottom', 'custom'
          customX = null,
          customY = null,
          linkColor = '#0066cc',
          linkUnderline = true,
          x = customX !== null && customY !== null && position === 'custom' ? customX : img.width / 2,
          y = customX !== null && customY !== null && position === 'custom' ? customY :
              position === 'top' ? fontSize + 20 :
              position === 'center' ? img.height / 2 :
              img.height - 20,
          maxWidth = img.width * 0.8
        } = options;

        // 대표글 그리기 (각 대표글을 개별적으로 처리)
        mainTexts.forEach(mainText => {
          if (mainText.text && mainText.text.trim()) {
            const {
              fontSize: textFontSize = Math.max(img.width, img.height) * 0.05,
              color: textColor = '#ffffff',
              strokeColor: textStrokeColor = '#000000',
              strokeWidth: textStrokeWidth = 2,
              customX: textCustomX = null,
              customY: textCustomY = null,
              position: textPosition = 'bottom'
            } = mainText;

            // 대표글 위치 계산
            const textX = textCustomX !== null ? textCustomX : img.width / 2;
            let textY;
            if (textCustomY !== null) {
              textY = textCustomY;
            } else {
              switch (textPosition) {
                case 'top':
                  textY = textFontSize + 20;
                  break;
                case 'center':
                  textY = img.height / 2;
                  break;
                case 'bottom':
                  textY = img.height - 20;
                  break;
                case 'custom':
                default:
                  textY = img.height / 2; // 기본값은 중앙
                  break;
              }
            }

            ctx.font = `${textFontSize}px ${fontFamily}`;
            ctx.textAlign = 'center';
            ctx.textBaseline = textPosition === 'top' ? 'top' :
                              textPosition === 'center' ? 'middle' : 'bottom';

            // 텍스트 줄바꿈 처리 (엔터키와 공백 모두 인식)
            const lines = [];
            const paragraphs = mainText.text.split('\n'); // 엔터키로 문단 분리

            paragraphs.forEach(paragraph => {
              if (paragraph.trim() === '') {
                // 빈 줄은 그대로 추가
                lines.push('');
                return;
              }

              const words = paragraph.split(' ');
              let currentLine = words[0] || '';

              for (let i = 1; i < words.length; i++) {
                const word = words[i];
                const width = ctx.measureText(currentLine + ' ' + word).width;
                if (width < maxWidth) {
                  currentLine += ' ' + word;
                } else {
                  lines.push(currentLine);
                  currentLine = word;
                }
              }
              if (currentLine) {
                lines.push(currentLine);
              }
            });

            // 각 줄에 텍스트 그리기
            lines.forEach((line, index) => {
              const lineY = textY + (index - (lines.length - 1) / 2) * (textFontSize + 5);

              // 텍스트 외곽선 (그림자 효과)
              if (textStrokeWidth > 0) {
                ctx.strokeStyle = textStrokeColor;
                ctx.lineWidth = textStrokeWidth;
                ctx.strokeText(line, textX, lineY);
              }

              // 텍스트 그리기
              ctx.fillStyle = textColor;
              ctx.fillText(line, textX, lineY);
            });
          }
        });

        // 링크 텍스트 그리기
        links.forEach(link => {
          if (link.position && link.text) {
            const linkX = link.position.x;
            const linkY = link.position.y;

            // 링크별 스타일 적용
            const linkStyle = link.style || {
              fontSize: 20,
              color: '#0066cc',
              strokeColor: '#000000',
              underline: true
            };

            const linkFontSize = linkStyle.fontSize || 20;
            const linkColor = linkStyle.color || '#0066cc';
            const linkStrokeColor = linkStyle.strokeColor || '#000000';
            const linkUnderline = linkStyle.underline !== undefined ? linkStyle.underline : true;

            // 링크 텍스트 그리기
            ctx.font = `${linkFontSize}px ${fontFamily}`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // 텍스트 외곽선
            ctx.strokeStyle = linkStrokeColor;
            ctx.lineWidth = 3;
            ctx.strokeText(link.text, linkX, linkY);

            // 링크 텍스트
            ctx.fillStyle = linkColor;
            ctx.fillText(link.text, linkX, linkY);

            // 링크 밑줄
            if (linkUnderline) {
              const textWidth = ctx.measureText(link.text).width;
              ctx.strokeStyle = linkColor;
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(linkX - textWidth / 2, linkY + linkFontSize / 2 + 3);
              ctx.lineTo(linkX + textWidth / 2, linkY + linkFontSize / 2 + 3);
              ctx.stroke();
            }
          }
        });

        // 캔버스를 Blob으로 변환
        canvas.toBlob((blob) => {
          const fileName = imageFile.name || `processed-image-${Date.now()}.png`;
          const fileType = imageFile.type || 'image/png';

          const file = new File([blob], fileName, {
            type: fileType,
            lastModified: Date.now()
          });
          resolve(file);
        }, imageFile.type || 'image/png');
      };

      img.onerror = reject;
      img.src = URL.createObjectURL(imageFile);
    });
  };

  // 텍스트 추가 처리
  const handleAddTextToImage = async () => {
    console.log('handleAddTextToImage 호출됨');
    console.log('imageFile:', imageFile);
    console.log('mainTexts:', mainTexts);
    console.log('mainTexts 길이:', mainTexts.length);
    console.log('links 상태:', links);
    console.log('links 길이:', links.length);

    if (!imageFile || (mainTexts.length === 0 && links.length === 0)) {
      console.log('이미지 파일이 없거나 대표글과 링크가 모두 없음');
      return;
    }

        try {
      const processedImage = await addTextToImage(imageFile, mainTexts, {
        fontSize: mainTextOptions.fontSize,
        color: mainTextOptions.color,
        strokeColor: mainTextOptions.strokeColor,
        position: mainTextOptions.position,
        customX: mainTextOptions.customX,
        customY: mainTextOptions.customY
      }, links); // 링크 배열 전달

      // 대표글과 링크 정보와 함께 결과 반환
      const result = {
        imageFile: processedImage,
        mainTexts: mainTexts || [], // 대표글 배열 전달
        links: links || [] // 링크 배열 전달
      };

      console.log('ImageTextModal - Sending result:', result);
      console.log('ImageTextModal - MainTexts in result:', result.mainTexts);
      console.log('ImageTextModal - Links in result:', result.links);
      console.log('ImageTextModal - MainTexts JSON:', JSON.stringify(result.mainTexts, null, 2));
      console.log('ImageTextModal - Links JSON:', JSON.stringify(result.links, null, 2));

      onConfirm(result);

      // 모달 상태 초기화
      setMainTexts([]);
      setLinks([]);
      setCurrentMainText({
        text: '',
        fontSize: 24,
        color: '#ffffff',
        strokeColor: '#000000',
        position: 'bottom',
        customX: null,
        customY: null,
        id: null
      });
      setCurrentLink({ url: '', text: '', position: null });
      setMainTextOptions({
        fontSize: 24,
        color: '#ffffff',
        strokeColor: '#000000',
        position: 'bottom',
        ...defaultOptions
      });
      setLinkOptions({
        fontSize: 20,
        color: '#0066cc',
        strokeColor: '#000000',
        underline: true,
        ...defaultOptions
      });
      setPreviewUrl('');
    } catch (error) {
      console.error('이미지 텍스트 추가 실패:', error);
    }
  };

  // 모달 닫기
  const handleClose = () => {
    // 모든 상태 초기화
    setMainTexts([]);
    setLinks([]);
    setCurrentMainText({
      text: '',
      fontSize: 24,
      color: '#ffffff',
      strokeColor: '#000000',
      position: 'bottom',
      customX: null,
      customY: null,
      id: null
    });
    setCurrentLink({ url: '', text: '', position: null });
    setMainTextOptions({
      fontSize: 24,
      color: '#ffffff',
      strokeColor: '#000000',
      position: 'bottom',
      ...defaultOptions
    });
    setLinkOptions({
      fontSize: 20,
      color: '#0066cc',
      strokeColor: '#000000',
      underline: true,
      ...defaultOptions
    });
    setPreviewUrl('');
    setIsDragging(false);
    setDraggedLinkId(null);
    setDragOffset({ x: 0, y: 0 });

    // 부모 컴포넌트에 닫기 알림
    onClose();
  };

  if (!isOpen || !imageFile) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-white rounded-lg w-11/12 sm:w-5/6 md:w-4/5 lg:w-3/4 xl:w-2/3 max-w-6xl max-h-[90vh] overflow-hidden">
        {/* 모달 헤더 */}
        <div className="flex items-center justify-between p-2 sm:p-3 md:p-4 border-b">
          <h3 className="text-sm sm:text-base md:text-lg font-semibold">이미지에 텍스트 추가</h3>
          <button
            onClick={handleClose}
            className="text-gray-500 hover:text-gray-700"
          >
            <X className="w-6 h-6" />
          </button>
        </div>

        {/* 모달 내용 */}
        <div className="p-2 sm:p-3 md:p-4 max-h-[calc(90vh-120px)] overflow-auto">
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-4">
            {/* 왼쪽: 설정 패널 */}
            <div className="space-y-6">
              {/* 대표글 입력 */}
              <div className="bg-blue-50 p-4 rounded-lg border border-blue-200">
                <label className="block text-sm font-semibold text-blue-800 mb-2 flex items-center gap-2">
                  📝 대표글 입력
                </label>
                <textarea
                  value={currentMainText.text}
                  onChange={(e) => setCurrentMainText(prev => ({ ...prev, text: e.target.value }))}
                  placeholder="이미지에 추가할 대표글을 입력하세요 (선택사항)"
                  className="w-full p-3 border border-blue-300 rounded-lg resize-none bg-white"
                  rows={3}
                />

                {/* 대표글 스타일 옵션 */}
                <div className="grid grid-cols-2 gap-2 mt-3">
                  <div>
                    <label className="block text-xs text-blue-700 mb-1">폰트 크기</label>
                    <input
                      type="range"
                      min="12"
                      max="72"
                      value={currentMainText.fontSize}
                      onChange={(e) => setCurrentMainText(prev => ({ ...prev, fontSize: parseInt(e.target.value) }))}
                      className="w-full"
                    />
                    <span className="text-xs text-blue-600">{currentMainText.fontSize}px</span>
                  </div>
                  <div>
                    <label className="block text-xs text-blue-700 mb-1">색상</label>
                    <input
                      type="color"
                      value={currentMainText.color}
                      onChange={(e) => setCurrentMainText(prev => ({ ...prev, color: e.target.value }))}
                      className="w-full h-8 border border-blue-300 rounded"
                    />
                  </div>
                </div>

                {/* 대표글 위치 설정 */}
                <div className="mt-3">
                  <label className="block text-xs text-blue-700 mb-1">위치</label>
                  <select
                    value={currentMainText.position}
                    onChange={(e) => setCurrentMainText(prev => ({
                      ...prev,
                      position: e.target.value,
                      customX: null,
                      customY: null
                    }))}
                    className="w-full p-2 border border-blue-300 rounded text-sm"
                  >
                    <option value="top">상단</option>
                    <option value="center">중앙</option>
                    <option value="bottom">하단</option>
                    <option value="custom">드래그 위치</option>
                  </select>
                  {currentMainText.position === 'custom' && (
                    <p className="text-xs text-blue-600 mt-1">
                      💡 대표글을 추가한 후 미리보기에서 드래그하여 위치를 조정할 수 있습니다.
                    </p>
                  )}
                </div>

                <button
                  onClick={addMainText}
                  disabled={!currentMainText.text.trim()}
                  className={`w-full mt-3 px-3 py-2 rounded text-sm ${
                    !currentMainText.text.trim()
                      ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
                      : 'bg-blue-500 text-white hover:bg-blue-600'
                  }`}
                >
                  대표글 추가
                </button>

                {/* 추가된 대표글 목록 */}
                {mainTexts.length > 0 && (
                  <div className="space-y-2 mt-4">
                    <h4 className="text-sm font-semibold text-blue-800 flex items-center gap-2">
                      ✅ 추가된 대표글 ({mainTexts.length}개):
                    </h4>
                    {mainTexts.map((mainText, index) => (
                      <div key={mainText.id} className="flex items-center justify-between p-3 bg-white rounded-lg border border-blue-200 text-sm">
                        <div className="flex-1">
                          <div className="font-medium text-blue-800">{mainText.text}</div>
                          <div className="text-blue-600 text-xs">
                            크기: {mainText.fontSize}px | 색상: {mainText.color}
                          </div>
                        </div>
                        <button
                          onClick={() => removeMainText(mainText.id)}
                          className="ml-2 px-2 py-1 bg-red-500 text-white rounded hover:bg-red-600 text-xs"
                        >
                          삭제
                        </button>
                      </div>
                    ))}
                  </div>
                )}

                <p className="text-xs text-blue-600 mt-2">
                  대표글을 입력하지 않아도 링크만 추가할 수 있습니다.
                </p>
              </div>

              {/* 링크 관리 */}
              <div className="bg-green-50 p-4 rounded-lg border border-green-200">
                <label className="block text-sm font-semibold text-green-800 mb-2 flex items-center gap-2">
                  <Link className="w-4 h-4" />
                  🔗 링크 추가
                </label>

                                {/* 링크 입력 폼 */}
                <div className="space-y-2 mb-3">
                  <input
                    type="text"
                    value={currentLink.url}
                    onChange={(e) => setCurrentLink(prev => ({ ...prev, url: e.target.value }))}
                    placeholder="링크 URL을 입력하세요 (예: https://example.com)"
                    className={`w-full p-2 border rounded text-sm ${
                      currentLink.url && !isValidUrl(currentLink.url)
                        ? 'border-red-500 bg-red-50'
                        : 'border-gray-300'
                    }`}
                  />
                  {currentLink.url && !isValidUrl(currentLink.url) && (
                    <p className="text-xs text-red-600">유효한 URL을 입력해주세요 (http:// 또는 https:// 포함)</p>
                  )}
                  <input
                    type="text"
                    value={currentLink.text}
                    onChange={(e) => setCurrentLink(prev => ({ ...prev, text: e.target.value }))}
                    placeholder="링크 텍스트를 입력하세요"
                    className="w-full p-2 border border-gray-300 rounded text-sm"
                  />

                  {/* 링크 텍스트 미리보기 */}
                  {currentLink.text && (
                    <div className="p-2 bg-gray-50 rounded border">
                      <p className="text-xs text-gray-600 mb-1">링크 텍스트 미리보기:</p>
                      <div
                        className="text-center"
                        style={{
                          fontSize: `${linkOptions.fontSize}px`,
                          color: linkOptions.color,
                          textShadow: `2px 2px 2px ${linkOptions.strokeColor}`,
                          textDecoration: linkOptions.underline ? 'underline' : 'none',
                          textDecorationColor: linkOptions.color
                        }}
                      >
                        {currentLink.text}
                      </div>
                    </div>
                  )}

                  <button
                    onClick={() => {
                      console.log('링크 추가 버튼 클릭됨');
                      addLink();
                    }}
                    disabled={!currentLink.url.trim() || !currentLink.text.trim() || !isValidUrl(currentLink.url)}
                    className={`w-full px-3 py-2 rounded text-sm ${
                      !currentLink.url.trim() || !currentLink.text.trim() || !isValidUrl(currentLink.url)
                        ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
                        : 'bg-blue-500 text-white hover:bg-blue-600'
                    }`}
                  >
                    링크 추가
                  </button>
                </div>

                {/* 추가된 링크 목록 */}
                {links.length > 0 && (
                  <div className="space-y-2 mt-4">
                    <h4 className="text-sm font-semibold text-green-800 flex items-center gap-2">
                      ✅ 추가된 링크 ({links.length}개):
                    </h4>
                    {links.map((link, index) => (
                      <div key={link.id} className="flex items-center justify-between p-3 bg-white rounded-lg border border-green-200 text-sm">
                        <div className="flex-1">
                          <div className="font-medium text-green-800">{link.text}</div>
                          <div className="text-green-600 truncate text-xs">{link.url}</div>
                        </div>
                        <button
                          onClick={() => removeLink(link.id)}
                          className="ml-2 px-2 py-1 bg-red-500 text-white rounded hover:bg-red-600 text-xs"
                        >
                          삭제
                        </button>
                      </div>
                    ))}
                  </div>
                )}
              </div>

              {/* 기본 설정 (새 대표글의 기본값) */}
              <div className="bg-gray-50 p-4 rounded-lg border border-gray-200">
                <h4 className="text-sm font-medium text-gray-700 mb-3">⚙️ 기본 설정</h4>
                <p className="text-xs text-gray-600 mb-3">
                  새로 추가할 대표글의 기본 스타일을 설정합니다.
                </p>

                {/* 기본 폰트 크기 */}
                <div className="mb-3">
                  <label className="block text-xs text-gray-600 mb-1">기본 폰트 크기</label>
                  <input
                    type="range"
                    min="12"
                    max="72"
                    value={mainTextOptions.fontSize}
                    onChange={(e) => setMainTextOptions(prev => ({ ...prev, fontSize: parseInt(e.target.value) }))}
                    className="w-full"
                  />
                  <span className="text-xs text-gray-500">{mainTextOptions.fontSize}px</span>
                </div>

                {/* 기본 색상 */}
                <div className="grid grid-cols-2 gap-2 mb-3">
                  <div>
                    <label className="block text-xs text-gray-600 mb-1">기본 색상</label>
                    <input
                      type="color"
                      value={mainTextOptions.color}
                      onChange={(e) => setMainTextOptions(prev => ({ ...prev, color: e.target.value }))}
                      className="w-full h-8 border border-gray-300 rounded"
                    />
                  </div>
                  <div>
                    <label className="block text-xs text-gray-600 mb-1">기본 외곽선</label>
                    <input
                      type="color"
                      value={mainTextOptions.strokeColor}
                      onChange={(e) => setMainTextOptions(prev => ({ ...prev, strokeColor: e.target.value }))}
                      className="w-full h-8 border border-gray-300 rounded"
                    />
                  </div>
                </div>

                {/* 기본 위치 */}
                <div>
                  <label className="block text-xs text-gray-600 mb-1">기본 위치</label>
                  <select
                    value={mainTextOptions.position}
                    onChange={(e) => setMainTextOptions(prev => ({
                      ...prev,
                      position: e.target.value
                    }))}
                    className="w-full p-2 border border-gray-300 rounded text-xs"
                  >
                    <option value="top">상단</option>
                    <option value="center">중앙</option>
                    <option value="bottom">하단</option>
                    <option value="custom">드래그 위치</option>
                  </select>
                </div>
              </div>

                {/* 링크 스타일 설정 */}
                <div className="border-t pt-4">
                  <h4 className="text-sm font-medium text-gray-700 mb-3 flex items-center gap-2">
                    <Link className="w-4 h-4" />
                    링크 스타일 설정
                  </h4>

                  {/* 링크 폰트 크기 */}
                  <div className="mb-4">
                    <label className="block text-sm font-medium text-gray-700 mb-2">링크 폰트 크기</label>
                    <input
                      type="range"
                      min="12"
                      max="48"
                      value={linkOptions.fontSize}
                      onChange={(e) => setLinkOptions(prev => ({ ...prev, fontSize: parseInt(e.target.value) }))}
                      className="w-full"
                    />
                    <span className="text-sm text-gray-600">{linkOptions.fontSize}px</span>
                  </div>

                  {/* 링크 색상 선택 */}
                  <div className="grid grid-cols-2 gap-4 mb-4">
                    {/* 링크 텍스트 색상 */}
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-2">링크 색상</label>
                      <input
                        type="color"
                        value={linkOptions.color}
                        onChange={(e) => setLinkOptions(prev => ({ ...prev, color: e.target.value }))}
                        className="w-full h-10 border border-gray-300 rounded-lg"
                      />
                    </div>

                    {/* 링크 외곽선 색상 */}
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-2">외곽선 색상</label>
                      <input
                        type="color"
                        value={linkOptions.strokeColor}
                        onChange={(e) => setLinkOptions(prev => ({ ...prev, strokeColor: e.target.value }))}
                        className="w-full h-10 border border-gray-300 rounded-lg"
                      />
                    </div>
                  </div>

                  {/* 링크 밑줄 */}
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-2">밑줄 표시</label>
                    <div className="flex items-center">
                      <input
                        type="checkbox"
                        checked={linkOptions.underline}
                        onChange={(e) => setLinkOptions(prev => ({ ...prev, underline: e.target.checked }))}
                        className="mr-2"
                      />
                      <span className="text-sm text-gray-600">밑줄 표시</span>
                    </div>
                  </div>
                </div>
              </div>
            </div>

            {/* 오른쪽: 미리보기 */}
            <div className="space-y-4">
              <h4 className="text-sm font-medium text-gray-700">실시간 미리보기</h4>
              <div
                ref={previewContainerRef}
                className="flex justify-center relative"
                onMouseDown={handleMouseDown}
                onMouseMove={handleMouseMove}
                onMouseUp={handleMouseUp}
                onMouseLeave={handleMouseUp}
                style={{ cursor: (mainTextOptions.position === 'custom' && currentMainText.text.trim()) || links.length > 0 ? 'grab' : 'default' }}
              >
                {previewUrl ? (
                  <img
                    src={previewUrl}
                    alt="미리보기"
                    className="max-w-full max-h-64 object-contain rounded-lg border shadow-lg"
                    style={{
                      cursor: (mainTextOptions.position === 'custom' && currentMainText.text.trim()) || links.length > 0 ? 'grab' : 'default',
                      userSelect: 'none'
                    }}
                  />
                ) : (
                  <img
                    src={URL.createObjectURL(imageFile)}
                    alt="원본 이미지"
                    className="max-w-full max-h-64 object-contain rounded-lg border"
                    style={{
                      cursor: links.length > 0 ? 'grab' : 'default',
                      userSelect: 'none'
                    }}
                  />
                )}
              </div>
              <div className="text-xs text-gray-500 text-center">
                {mainTexts.length > 0 ?
                  (mainTextOptions.position === 'custom' ?
                    '📝 대표글을 드래그하여 위치 조정' :
                    '📝 대표글이 추가된 미리보기') :
                  links.length > 0 ?
                    '🔗 링크만 추가된 미리보기' :
                    '원본 이미지'}
                {links.length > 0 && (
                  <div className="mt-1 text-green-600">
                    🔗 {links.length}개의 링크가 포함됨 (드래그로 위치 조정 가능)
                  </div>
                )}
              </div>
            </div>
          </div>
        </div>

        {/* 모달 푸터 */}
        <div className="flex items-center justify-between p-2 sm:p-3 md:p-4 border-t bg-gray-50">
          <div className="text-sm text-gray-600">
            {mainTexts.length > 0 ? (
              mainTextOptions.position === 'custom' ?
                '📝 대표글을 드래그하여 원하는 위치에 배치하세요.' :
                '📝 대표글을 입력하면 실시간으로 미리보기가 업데이트됩니다.'
            ) : links.length > 0 ? (
              '🔗 링크만 추가된 상태입니다. 대표글을 입력하거나 링크를 더 추가할 수 있습니다.'
            ) : (
              '📝 대표글을 입력하거나 🔗 링크를 추가해보세요.'
            )}
            {links.length > 0 && (
              <span className="ml-2 text-green-600">🔗 {links.length}개의 링크가 포함됩니다.</span>
            )}
          </div>
          <div className="flex gap-1 sm:gap-2 flex-shrink-0">
            <button
              onClick={handleClose}
              className="px-2 sm:px-3 md:px-4 py-1 sm:py-2 bg-gray-500 text-white rounded hover:bg-gray-600 text-xs sm:text-sm"
            >
              취소
            </button>
            <button
              onClick={handleAddTextToImage}
              disabled={mainTexts.length === 0 && links.length === 0}
              className="px-2 sm:px-3 md:px-4 py-1 sm:py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed text-xs sm:text-sm"
            >
              {mainTexts.length > 0 ? '텍스트 추가' : links.length > 0 ? '링크 추가' : '텍스트 추가'}
            </button>
          </div>
        </div>
      </div>

      {/* 숨겨진 캔버스 (미리보기 생성용) */}
      <canvas ref={canvasRef} style={{ display: 'none' }} />
    </div>
  );
}

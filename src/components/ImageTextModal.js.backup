'use client';

import { Link, X } from 'lucide-react';
import { useCallback, useEffect, useRef, useState } from 'react';

/**
 * ì´ë¯¸ì§€ì— í…ìŠ¤íŠ¸ë¥¼ ì¶”ê°€í•˜ëŠ” ëª¨ë‹¬ ì»´í¬ë„ŒíŠ¸
 *
 * @param {Object} props
 * @param {boolean} props.isOpen - ëª¨ë‹¬ ì—´ë¦¼/ë‹«í˜ ìƒíƒœ
 * @param {Function} props.onClose - ëª¨ë‹¬ ë‹«ê¸° í•¨ìˆ˜
 * @param {File} props.imageFile - í…ìŠ¤íŠ¸ë¥¼ ì¶”ê°€í•  ì´ë¯¸ì§€ íŒŒì¼
 * @param {Function} props.onConfirm - í…ìŠ¤íŠ¸ ì¶”ê°€ ì™„ë£Œ ì‹œ í˜¸ì¶œë˜ëŠ” í•¨ìˆ˜ (processedImageFileì„ ë§¤ê°œë³€ìˆ˜ë¡œ ë°›ìŒ)
 * @param {Object} props.defaultOptions - ê¸°ë³¸ í…ìŠ¤íŠ¸ ì˜µì…˜
 */
export default function ImageTextModal({
  isOpen,
  onClose,
  imageFile,
  onConfirm,
  defaultOptions = {}
}) {
  // ëŒ€í‘œê¸€ ë°°ì—´ (ì—¬ëŸ¬ ê°œì˜ ëŒ€í‘œê¸€ì„ ê´€ë¦¬)
  const [mainTexts, setMainTexts] = useState([]);

  // í˜„ì¬ í¸ì§‘ ì¤‘ì¸ ëŒ€í‘œê¸€
  const [currentMainText, setCurrentMainText] = useState({
    text: '',
    fontSize: 24,
    color: '#ffffff',
    strokeColor: '#000000',
    position: 'bottom',
    customX: null,
    customY: null,
    id: null
  });

  // ë§í¬ ë°°ì—´
  const [links, setLinks] = useState([]);

  // links ìƒíƒœ ë³€ê²½ ê°ì§€
  useEffect(() => {
    console.log('links ìƒíƒœ ë³€ê²½ë¨:', links);
    console.log('links ê¸¸ì´:', links.length);
  }, [links]);

  // mainTexts ìƒíƒœ ë³€ê²½ ê°ì§€
  useEffect(() => {
    console.log('mainTexts ìƒíƒœ ë³€ê²½ë¨:', mainTexts);
    console.log('mainTexts ê¸¸ì´:', mainTexts.length);
  }, [mainTexts]);

  const [currentLink, setCurrentLink] = useState({
    url: '',
    text: '',
    position: null
  });

  // ëŒ€í‘œê¸€ ê¸°ë³¸ ì˜µì…˜
  const [mainTextOptions, setMainTextOptions] = useState({
    fontSize: 24,
    color: '#ffffff',
    strokeColor: '#000000',
    position: 'bottom',
    ...defaultOptions
  });

  // ë§í¬ ê¸°ë³¸ ì˜µì…˜
  const [linkOptions, setLinkOptions] = useState({
    fontSize: 20,
    color: '#0066cc',
    strokeColor: '#000000',
    underline: true,
    ...defaultOptions
  });
  const [previewUrl, setPreviewUrl] = useState('');
  const [isDragging, setIsDragging] = useState(false);
  const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
  const [draggedLinkId, setDraggedLinkId] = useState(null);
  const canvasRef = useRef(null);
  const imageRef = useRef(null);
  const previewContainerRef = useRef(null);
  const updatePreviewRef = useRef(null);

  // ì´ë¯¸ì§€ ë¡œë“œ ë° ë¯¸ë¦¬ë³´ê¸° ìƒì„±
  useEffect(() => {
    if (imageFile && canvasRef.current) {
      const img = new Image();
      img.onload = () => {
        imageRef.current = img;
        // updatePreview í•¨ìˆ˜ê°€ ì •ì˜ëœ í›„ì—ë§Œ í˜¸ì¶œ
        if (updatePreviewRef.current) {
          updatePreviewRef.current();
        }
      };
      img.src = URL.createObjectURL(imageFile);
    }
  }, [imageFile]);

  // í…ìŠ¤íŠ¸ë‚˜ ì˜µì…˜ ë³€ê²½ ì‹œ ë¯¸ë¦¬ë³´ê¸° ì—…ë°ì´íŠ¸
  useEffect(() => {
    if (imageRef.current && updatePreviewRef.current) {
      updatePreviewRef.current();
    }
  }, [mainTexts, mainTextOptions, links, linkOptions]);

  // ëª¨ë‹¬ì´ ì—´ë¦´ ë•Œ ìƒíƒœ ì´ˆê¸°í™”
  useEffect(() => {
    if (isOpen && imageFile) {
      console.log('ëª¨ë‹¬ ì—´ë¦¼ - ìƒíƒœ ì´ˆê¸°í™”');
      // ëª¨ë‹¬ì´ ì—´ë¦´ ë•Œ ìƒíƒœ ì´ˆê¸°í™”
      setMainTexts([]);
      setLinks([]);
      setCurrentMainText({
        text: '',
        fontSize: 24,
        color: '#ffffff',
        strokeColor: '#000000',
        position: 'bottom',
        customX: null,
        customY: null,
        id: null
      });
      setCurrentLink({ url: '', text: '', position: null });
      setMainTextOptions({
        fontSize: 24,
        color: '#ffffff',
        strokeColor: '#000000',
        position: 'bottom',
        ...defaultOptions
      });
      setPreviewUrl('');
      setIsDragging(false);
      setDraggedLinkId(null);
      setDragOffset({ x: 0, y: 0 });
    }
  }, [isOpen, imageFile]); // defaultOptions ì œê±°

  // ë“œë˜ê·¸ ì‹œì‘
  const handleMouseDown = (e) => {
    if (!previewContainerRef.current) return;

    const rect = previewContainerRef.current.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    const img = imageRef.current;
    if (!img) return;

    const scaleX = img.width / rect.width;
    const scaleY = img.height / rect.height;

    // ë§í¬ ë“œë˜ê·¸ í™•ì¸
    for (let i = links.length - 1; i >= 0; i--) {
      const link = links[i];
      if (link.position) {
        const linkX = link.position.x / scaleX;
        const linkY = link.position.y / scaleY;
        const linkWidth = link.position.width / scaleX;
        const linkHeight = link.position.height / scaleY;

        if (Math.abs(x - linkX) < linkWidth / 2 + 10 &&
            Math.abs(y - linkY) < linkHeight / 2 + 10) {
          setIsDragging(true);
          setDraggedLinkId(link.id);
          setDragOffset({
            x: x - linkX,
            y: y - linkY
          });
          return;
        }
      }
    }

    // ëŒ€í‘œê¸€ ë“œë˜ê·¸ í™•ì¸ (ê° ëŒ€í‘œê¸€ì„ ê°œë³„ì ìœ¼ë¡œ í™•ì¸)
    for (let i = mainTexts.length - 1; i >= 0; i--) {
      const mainText = mainTexts[i];
      if (mainText.customX !== null && mainText.customY !== null) {
        const textX = mainText.customX / scaleX;
        const textY = mainText.customY / scaleY;
        const fontSize = mainText.fontSize / scaleY;

        // ëŒ€í‘œê¸€ í…ìŠ¤íŠ¸ ë„ˆë¹„ ê³„ì‚°
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        ctx.font = `${mainText.fontSize}px Arial, sans-serif`;
        const textWidth = ctx.measureText(mainText.text).width / scaleX;

        if (Math.abs(x - textX) < textWidth / 2 + 20 &&
            Math.abs(y - textY) < fontSize + 20) {
          setIsDragging(true);
          setDraggedLinkId(`mainText_${mainText.id}`);
          setDragOffset({
            x: x - textX,
            y: y - textY
          });
          return;
        }
      }
    }
  };

  // ë“œë˜ê·¸ ì¤‘
  const handleMouseMove = (e) => {
    if (!isDragging || !previewContainerRef.current || !imageRef.current) return;

    const rect = previewContainerRef.current.getBoundingClientRect();
    const x = e.clientX - rect.left - dragOffset.x;
    const y = e.clientY - rect.top - dragOffset.y;

    const img = imageRef.current;
    const scaleX = img.width / rect.width;
    const scaleY = img.height / rect.height;

    // ì´ë¯¸ì§€ ê²½ê³„ ë‚´ë¡œ ì œí•œ
    const newX = Math.max(0, Math.min(img.width, x * scaleX));
    const newY = Math.max(0, Math.min(img.height, y * scaleY));

    if (draggedLinkId && draggedLinkId.startsWith('mainText_')) {
      // ëŒ€í‘œê¸€ ë“œë˜ê·¸
      const mainTextId = draggedLinkId.replace('mainText_', '');
      setMainTexts(prev => prev.map(mainText =>
        mainText.id === mainTextId
          ? { ...mainText, customX: newX, customY: newY }
          : mainText
      ));
    } else if (draggedLinkId) {
      // ë§í¬ ë“œë˜ê·¸
      setLinks(prev => prev.map(link =>
        link.id === draggedLinkId
          ? { ...link, position: { ...link.position, x: newX, y: newY } }
          : link
      ));
    }
  };

  // ë“œë˜ê·¸ ì¢…ë£Œ
  const handleMouseUp = () => {
    setIsDragging(false);
    setDraggedLinkId(null);
  };

  // í…ìŠ¤íŠ¸ ë„ˆë¹„ ê³„ì‚°
  const getTextWidth = useCallback(() => {
    if (!imageRef.current) return 0;

    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    ctx.font = `${mainTextOptions.fontSize}px Arial, sans-serif`;

    // í˜„ì¬ í¸ì§‘ ì¤‘ì¸ ëŒ€í‘œê¸€ í…ìŠ¤íŠ¸ ì‚¬ìš©
    const words = currentMainText.text.split(' ');
    let maxWidth = 0;

    words.forEach(word => {
      const width = ctx.measureText(word).width;
      maxWidth = Math.max(maxWidth, width);
    });

    return maxWidth;
  }, [currentMainText.text, mainTextOptions.fontSize]);

  // ë§í¬ í…ìŠ¤íŠ¸ ë„ˆë¹„ ê³„ì‚°
  const getLinkTextWidth = useCallback((text, fontSize = linkOptions.fontSize) => {
    if (!imageRef.current) return 0;

    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    ctx.font = `${fontSize}px Arial, sans-serif`;

    return ctx.measureText(text).width;
  }, [linkOptions.fontSize]);

  // ê¸°ë³¸ Y ìœ„ì¹˜ ê³„ì‚°
  const getDefaultY = useCallback(() => {
    if (!imageRef.current) return 0;

    const img = imageRef.current;
    const { fontSize, position } = mainTextOptions;

    switch (position) {
      case 'top':
        return fontSize + 20;
      case 'center':
        return img.height / 2;
      case 'bottom':
        return img.height - 20;
      default:
        return img.height - 20;
    }
  }, [mainTextOptions.fontSize, mainTextOptions.position]);

  // URL ìœ íš¨ì„± ê²€ì‚¬
  const isValidUrl = (string) => {
    try {
      new URL(string);
      return true;
    } catch (_) {
      return false;
    }
  };

  // ë§í¬ ì¶”ê°€
  const addLink = () => {
    console.log('addLink í˜¸ì¶œë¨');
    console.log('currentLink:', currentLink);
    console.log('currentLink.url:', currentLink.url);
    console.log('currentLink.text:', currentLink.text);
    console.log('isValidUrl(currentLink.url):', isValidUrl(currentLink.url));

    if (!currentLink.url.trim() || !isValidUrl(currentLink.url)) {
      console.log('URL ìœ íš¨ì„± ê²€ì‚¬ ì‹¤íŒ¨');
      alert('ìœ íš¨í•œ URLì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
      return;
    }

    if (!currentLink.text.trim()) {
      console.log('ë§í¬ í…ìŠ¤íŠ¸ ê²€ì‚¬ ì‹¤íŒ¨');
      alert('ë§í¬ í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.');
      return;
    }

    // ì´ë¯¸ì§€ ì°¸ì¡° í™•ì¸
    const img = imageRef.current;
    if (!img) {
      alert('ì´ë¯¸ì§€ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ì…ë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.');
      return;
    }

    // ë§í¬ ìœ„ì¹˜ ê³„ì‚° - ê¸°ì¡´ ë§í¬ë“¤ê³¼ ê²¹ì¹˜ì§€ ì•Šë„ë¡ ì¡°ì •
    let x, y;
    const existingLinks = links || [];

    // ê¸°ë³¸ ì‹œì‘ ìœ„ì¹˜ (ë©”ì¸ í…ìŠ¤íŠ¸ì™€ ê²¹ì¹˜ì§€ ì•Šë„ë¡)
    let baseX, baseY;
    if (mainTextOptions.customX !== null && mainTextOptions.customY !== null) {
      // ë©”ì¸ í…ìŠ¤íŠ¸ê°€ ì»¤ìŠ¤í…€ ìœ„ì¹˜ì— ìˆëŠ” ê²½ìš°
      baseX = mainTextOptions.customX + 50;
      baseY = mainTextOptions.customY + 30;
    } else {
      // ê¸°ë³¸ ìœ„ì¹˜ ê³„ì‚°
      baseX = img.width / 2 + 50; // ë©”ì¸ í…ìŠ¤íŠ¸ë³´ë‹¤ ì˜¤ë¥¸ìª½ìœ¼ë¡œ
      baseY = getDefaultY() + 30; // ë©”ì¸ í…ìŠ¤íŠ¸ë³´ë‹¤ ì•„ë˜ë¡œ
    }

    // ê¸°ì¡´ ë§í¬ë“¤ê³¼ ê²¹ì¹˜ì§€ ì•ŠëŠ” ìœ„ì¹˜ ì°¾ê¸°
    let offsetX = 0;
    let offsetY = 0;
    let attempts = 0;
    const maxAttempts = 20;

    do {
      x = baseX + offsetX;
      y = baseY + offsetY;

      // ì´ë¯¸ì§€ ê²½ê³„ ë‚´ë¡œ ì œí•œ
      x = Math.max(50, Math.min(img.width - 50, x));
      y = Math.max(30, Math.min(img.height - 30, y));

      // ê¸°ì¡´ ë§í¬ë“¤ê³¼ ê²¹ì¹˜ëŠ”ì§€ í™•ì¸
      const overlaps = existingLinks.some(link => {
        const linkX = link.position.x;
        const linkY = link.position.y;
        const linkWidth = link.position.width;
        const linkHeight = link.position.height;

        // ê°„ë‹¨í•œ ì‚¬ê°í˜• ê²¹ì¹¨ ê²€ì‚¬
        return !(x + 10 < linkX || x > linkX + linkWidth + 10 ||
                y + 5 < linkY || y > linkY + linkHeight + 5);
      });

      if (!overlaps) break;

      // ê²¹ì¹˜ë©´ ìœ„ì¹˜ë¥¼ ì¡°ì •
      offsetX += 20;
      if (offsetX > 200) {
        offsetX = 0;
        offsetY += 25;
      }

      attempts++;
    } while (attempts < maxAttempts);

    // ìµœëŒ€ ì‹œë„ íšŸìˆ˜ë¥¼ ì´ˆê³¼í•˜ë©´ ë§ˆì§€ë§‰ ìœ„ì¹˜ ì‚¬ìš©
    if (attempts >= maxAttempts) {
      x = baseX + 200;
      y = baseY + 100;
      x = Math.max(50, Math.min(img.width - 50, x));
      y = Math.max(30, Math.min(img.height - 30, y));
    }

    const linkTextWidth = getLinkTextWidth(currentLink.text, linkOptions.fontSize);
    const linkTextHeight = linkOptions.fontSize;

    const newLink = {
      id: `link_${Date.now()}`,
      url: currentLink.url,
      text: currentLink.text,
      position: {
        x: x,
        y: y,
        width: linkTextWidth,
        height: linkTextHeight
      },
      style: {
        fontSize: linkOptions.fontSize,
        color: linkOptions.color,
        strokeColor: linkOptions.strokeColor,
        underline: linkOptions.underline
      }
    };

        setLinks(prev => {
      const newLinks = [...prev, newLink];
      console.log('ë§í¬ ì¶”ê°€ë¨:', newLink);
      console.log('í˜„ì¬ ë§í¬ ëª©ë¡:', newLinks);
      console.log('ë§í¬ ê°œìˆ˜:', newLinks.length);
      return newLinks;
    });
    setCurrentLink({ url: '', text: '', position: null });

    // ì„±ê³µ ë©”ì‹œì§€ (ì„ íƒì‚¬í•­)
    // alert('ë§í¬ê°€ ì„±ê³µì ìœ¼ë¡œ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤!');
  };

  // ëŒ€í‘œê¸€ ì¶”ê°€
  const addMainText = () => {
    if (!currentMainText.text.trim()) {
      alert('ëŒ€í‘œê¸€ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
      return;
    }

    const img = imageRef.current;
    if (!img) {
      alert('ì´ë¯¸ì§€ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ì…ë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.');
      return;
    }

    // ëŒ€í‘œê¸€ ìœ„ì¹˜ ê³„ì‚°
    let x, y;
    if (currentMainText.customX !== null && currentMainText.customY !== null) {
      x = currentMainText.customX;
      y = currentMainText.customY;
    } else {
      x = img.width / 2;
      // ì„ íƒëœ ìœ„ì¹˜ì— ë”°ë¼ Y ì¢Œí‘œ ê²°ì •
      switch (currentMainText.position) {
        case 'top':
          y = currentMainText.fontSize + 20;
          break;
        case 'center':
          y = img.height / 2;
          break;
        case 'bottom':
          y = img.height - 20;
          break;
        case 'custom':
        default:
          y = img.height / 2; // ê¸°ë³¸ê°’ì€ ì¤‘ì•™
          break;
      }
    }

    // ì»¤ìŠ¤í…€ ìœ„ì¹˜ë¡œ ì„¤ì • (ë“œë˜ê·¸ ê°€ëŠ¥í•˜ë„ë¡)
    const customX = x;
    const customY = y;

          const newMainText = {
        id: `mainText_${Date.now()}`,
        text: currentMainText.text,
        fontSize: currentMainText.fontSize,
        color: currentMainText.color,
        strokeColor: currentMainText.strokeColor,
        position: currentMainText.position,
        customX: customX,
        customY: customY
      };

    setMainTexts(prev => {
      const newMainTexts = [...prev, newMainText];
      console.log('ëŒ€í‘œê¸€ ì¶”ê°€ë¨:', newMainText);
      console.log('í˜„ì¬ ëŒ€í‘œê¸€ ëª©ë¡:', newMainTexts);
      console.log('ëŒ€í‘œê¸€ ê°œìˆ˜:', newMainTexts.length);
      return newMainTexts;
    });

    // í˜„ì¬ í¸ì§‘ ì¤‘ì¸ ëŒ€í‘œê¸€ ì´ˆê¸°í™”
    setCurrentMainText({
      text: '',
      fontSize: mainTextOptions.fontSize,
      color: mainTextOptions.color,
      strokeColor: mainTextOptions.strokeColor,
      position: mainTextOptions.position,
      customX: null,
      customY: null,
      id: null
    });
  };

  // ëŒ€í‘œê¸€ ì‚­ì œ
  const removeMainText = (mainTextId) => {
    setMainTexts(prev => prev.filter(mainText => mainText.id !== mainTextId));
  };

  // ë§í¬ ì‚­ì œ
  const removeLink = (linkId) => {
    setLinks(prev => prev.filter(link => link.id !== linkId));
  };

  // ë¯¸ë¦¬ë³´ê¸° ì—…ë°ì´íŠ¸ í•¨ìˆ˜
  const updatePreview = useCallback(() => {
    if (!imageRef.current || !canvasRef.current) return;

    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    const img = imageRef.current;

    // ìº”ë²„ìŠ¤ í¬ê¸° ì„¤ì •
    canvas.width = img.width;
    canvas.height = img.height;

    // ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
    ctx.drawImage(img, 0, 0);

    // ëŒ€í‘œê¸€ ê·¸ë¦¬ê¸°
    mainTexts.forEach((mainText, index) => {
      if (mainText.text) {
        const {
          fontSize,
          color,
          strokeColor,
          position,
          customX,
          customY
        } = mainText;

        // X, Y ì¢Œí‘œ ê²°ì • (ì»¤ìŠ¤í…€ ìœ„ì¹˜ ìš°ì„ )
        let x, y;
        if (customX !== null && customY !== null) {
          x = customX;
          y = customY;
        } else {
          x = img.width / 2;
          // ì„ íƒëœ ìœ„ì¹˜ì— ë”°ë¼ Y ì¢Œí‘œ ê²°ì •
          switch (position) {
            case 'top':
              y = fontSize + 20;
              break;
            case 'center':
              y = img.height / 2;
              break;
            case 'bottom':
              y = img.height - 20;
              break;
            case 'custom':
            default:
              y = img.height / 2; // ê¸°ë³¸ê°’ì€ ì¤‘ì•™
              break;
          }
        }

        const maxWidth = img.width * 0.8;

        ctx.font = `${fontSize}px Arial, sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = position === 'top' ? 'top' :
                          position === 'center' ? 'middle' : 'bottom';

        // í…ìŠ¤íŠ¸ ì¤„ë°”ê¿ˆ ì²˜ë¦¬ (ì—”í„°í‚¤ì™€ ê³µë°± ëª¨ë‘ ì¸ì‹)
        const lines = [];
        const paragraphs = mainText.text.split('\n'); // ì—”í„°í‚¤ë¡œ ë¬¸ë‹¨ ë¶„ë¦¬

        paragraphs.forEach(paragraph => {
          if (paragraph.trim() === '') {
            // ë¹ˆ ì¤„ì€ ê·¸ëŒ€ë¡œ ì¶”ê°€
            lines.push('');
            return;
          }

          const words = paragraph.split(' ');
          let currentLine = words[0] || '';

          for (let i = 1; i < words.length; i++) {
            const word = words[i];
            const width = ctx.measureText(currentLine + ' ' + word).width;
            if (width < maxWidth) {
              currentLine += ' ' + word;
            } else {
              lines.push(currentLine);
              currentLine = word;
            }
          }
          if (currentLine) {
            lines.push(currentLine);
          }
        });

        // ê° ì¤„ì— í…ìŠ¤íŠ¸ ê·¸ë¦¬ê¸°
        lines.forEach((line, lineIndex) => {
          const lineY = y + (lineIndex - (lines.length - 1) / 2) * (fontSize + 5);

          // í…ìŠ¤íŠ¸ ì™¸ê³½ì„  (ê·¸ë¦¼ì íš¨ê³¼)
          ctx.strokeStyle = strokeColor;
          ctx.lineWidth = 2;
          ctx.strokeText(line, x, lineY);

          // í…ìŠ¤íŠ¸ ê·¸ë¦¬ê¸°
          ctx.fillStyle = color;
          ctx.fillText(line, x, lineY);
        });

        // ëŒ€í‘œê¸€ ì˜ì—­ í‘œì‹œ
        ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
        ctx.lineWidth = 1;
        ctx.setLineDash([3, 3]);
        ctx.strokeRect(
          x - maxWidth / 2 - 10,
          y - fontSize / 2 - 10,
          maxWidth + 20,
          fontSize * lines.length + 20
        );
        ctx.setLineDash([]);

        // ëŒ€í‘œê¸€ ë²ˆí˜¸ í‘œì‹œ
        ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
        ctx.font = '12px Arial, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(`ëŒ€í‘œê¸€ ${index + 1}`, x, y - fontSize / 2 - 20);
      }
    });

    // ë§í¬ í…ìŠ¤íŠ¸ ê·¸ë¦¬ê¸°
    links.forEach((link, index) => {
      if (link.position && link.text) {
        const x = link.position.x;
        const y = link.position.y;

        // ë§í¬ë³„ ìŠ¤íƒ€ì¼ ì ìš©
        const linkStyle = link.style || linkOptions;
        const fontSize = linkStyle.fontSize || linkOptions.fontSize;
        const color = linkStyle.color || linkOptions.color;
        const strokeColor = linkStyle.strokeColor || linkOptions.strokeColor;
        const underline = linkStyle.underline !== undefined ? linkStyle.underline : linkOptions.underline;

        // ë§í¬ í…ìŠ¤íŠ¸ ê·¸ë¦¬ê¸°
        ctx.font = `${fontSize}px Arial, sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        // í…ìŠ¤íŠ¸ ì™¸ê³½ì„ 
        ctx.strokeStyle = strokeColor;
        ctx.lineWidth = 3;
        ctx.strokeText(link.text, x, y);

        // ë§í¬ í…ìŠ¤íŠ¸
        ctx.fillStyle = color;
        ctx.fillText(link.text, x, y);

        // ë§í¬ ë°‘ì¤„
        if (underline) {
          const textWidth = ctx.measureText(link.text).width;
          ctx.strokeStyle = color;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x - textWidth / 2, y + fontSize / 2 + 3);
          ctx.lineTo(x + textWidth / 2, y + fontSize / 2 + 3);
          ctx.stroke();
        }

        // ë§í¬ ì˜ì—­ í‘œì‹œ (ë” ëª…í™•í•˜ê²Œ)
        ctx.strokeStyle = 'rgba(0, 102, 204, 0.7)';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.strokeRect(
          x - link.position.width / 2 - 5,
          y - link.position.height / 2 - 5,
          link.position.width + 10,
          link.position.height + 10
        );
        ctx.setLineDash([]);

        // ë§í¬ ë²ˆí˜¸ í‘œì‹œ
        ctx.fillStyle = 'rgba(0, 102, 204, 0.8)';
        ctx.font = '12px Arial, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(`${index + 1}`, x, y - link.position.height / 2 - 10);
      }
    });

    // í˜„ì¬ ì…ë ¥ ì¤‘ì¸ ë§í¬ ë¯¸ë¦¬ë³´ê¸° (ë§í¬ í…ìŠ¤íŠ¸ê°€ ìˆê³  ìœ„ì¹˜ê°€ ê³„ì‚°ëœ ê²½ìš°)
    if (currentLink.text && currentLink.position) {
      const x = currentLink.position.x;
      const y = currentLink.position.y;
      const fontSize = linkOptions.fontSize;
      const color = linkOptions.color;
      const strokeColor = linkOptions.strokeColor;

      ctx.font = `${fontSize}px Arial, sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      // í…ìŠ¤íŠ¸ ì™¸ê³½ì„ 
      ctx.strokeStyle = strokeColor;
      ctx.lineWidth = 3;
      ctx.strokeText(currentLink.text, x, y);

      // ë§í¬ í…ìŠ¤íŠ¸
      ctx.fillStyle = color;
      ctx.fillText(currentLink.text, x, y);

      // ë§í¬ ë°‘ì¤„
      if (linkOptions.underline) {
        const textWidth = ctx.measureText(currentLink.text).width;
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x - textWidth / 2, y + fontSize / 2 + 3);
        ctx.lineTo(x + textWidth / 2, y + fontSize / 2 + 3);
        ctx.stroke();
      }

      // í˜„ì¬ ë§í¬ ì˜ì—­ í‘œì‹œ (ì ì„ ìœ¼ë¡œ êµ¬ë¶„)
      ctx.strokeStyle = 'rgba(255, 0, 0, 0.7)';
      ctx.lineWidth = 2;
      ctx.setLineDash([3, 3]);
      ctx.strokeRect(
        x - getLinkTextWidth(currentLink.text, fontSize) / 2 - 5,
        y - fontSize / 2 - 5,
        getLinkTextWidth(currentLink.text, fontSize) + 10,
        fontSize + 10
      );
      ctx.setLineDash([]);
    }

    // ìº”ë²„ìŠ¤ë¥¼ URLë¡œ ë³€í™˜í•˜ì—¬ ë¯¸ë¦¬ë³´ê¸° ì—…ë°ì´íŠ¸
    setPreviewUrl(canvas.toDataURL());
  }, [mainTexts, mainTextOptions, links, linkOptions, currentLink, getDefaultY]);

  // updatePreview í•¨ìˆ˜ë¥¼ refì— í• ë‹¹
  updatePreviewRef.current = updatePreview;

  // ìœ„ì¹˜ ì´ˆê¸°í™”
  const resetPosition = () => {
    setMainTextOptions(prev => ({
      ...prev,
      customX: null,
      customY: null,
      position: 'bottom'
    }));
  };

  // ì´ë¯¸ì§€ì— í…ìŠ¤íŠ¸ì™€ ë§í¬ ì¶”ê°€ í•¨ìˆ˜ (ìµœì¢… ì²˜ë¦¬ìš©)
  const addTextToImage = (imageFile, mainTexts = [], options = {}, links = []) => {
    return new Promise((resolve, reject) => {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const img = new Image();

      img.onload = () => {
        // ìº”ë²„ìŠ¤ í¬ê¸°ë¥¼ ì´ë¯¸ì§€ í¬ê¸°ë¡œ ì„¤ì •
        canvas.width = img.width;
        canvas.height = img.height;

        // ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
        ctx.drawImage(img, 0, 0);

        // í…ìŠ¤íŠ¸ ìŠ¤íƒ€ì¼ ì„¤ì •
        const {
          fontSize = Math.max(img.width, img.height) * 0.05, // ì´ë¯¸ì§€ í¬ê¸°ì˜ 5%
          fontFamily = 'Arial, sans-serif',
          color = '#ffffff',
          strokeColor = '#000000',
          strokeWidth = 2,
          position = 'bottom', // 'top', 'center', 'bottom', 'custom'
          customX = null,
          customY = null,
          linkColor = '#0066cc',
          linkUnderline = true,
          x = customX !== null && customY !== null && position === 'custom' ? customX : img.width / 2,
          y = customX !== null && customY !== null && position === 'custom' ? customY :
              position === 'top' ? fontSize + 20 :
              position === 'center' ? img.height / 2 :
              img.height - 20,
          maxWidth = img.width * 0.8
        } = options;

        // ëŒ€í‘œê¸€ ê·¸ë¦¬ê¸° (ê° ëŒ€í‘œê¸€ì„ ê°œë³„ì ìœ¼ë¡œ ì²˜ë¦¬)
        mainTexts.forEach(mainText => {
          if (mainText.text && mainText.text.trim()) {
            const {
              fontSize: textFontSize = Math.max(img.width, img.height) * 0.05,
              color: textColor = '#ffffff',
              strokeColor: textStrokeColor = '#000000',
              strokeWidth: textStrokeWidth = 2,
              customX: textCustomX = null,
              customY: textCustomY = null,
              position: textPosition = 'bottom'
            } = mainText;

            // ëŒ€í‘œê¸€ ìœ„ì¹˜ ê³„ì‚°
            const textX = textCustomX !== null ? textCustomX : img.width / 2;
            let textY;
            if (textCustomY !== null) {
              textY = textCustomY;
            } else {
              switch (textPosition) {
                case 'top':
                  textY = textFontSize + 20;
                  break;
                case 'center':
                  textY = img.height / 2;
                  break;
                case 'bottom':
                  textY = img.height - 20;
                  break;
                case 'custom':
                default:
                  textY = img.height / 2; // ê¸°ë³¸ê°’ì€ ì¤‘ì•™
                  break;
              }
            }

            ctx.font = `${textFontSize}px ${fontFamily}`;
            ctx.textAlign = 'center';
            ctx.textBaseline = textPosition === 'top' ? 'top' :
                              textPosition === 'center' ? 'middle' : 'bottom';

            // í…ìŠ¤íŠ¸ ì¤„ë°”ê¿ˆ ì²˜ë¦¬ (ì—”í„°í‚¤ì™€ ê³µë°± ëª¨ë‘ ì¸ì‹)
            const lines = [];
            const paragraphs = mainText.text.split('\n'); // ì—”í„°í‚¤ë¡œ ë¬¸ë‹¨ ë¶„ë¦¬

            paragraphs.forEach(paragraph => {
              if (paragraph.trim() === '') {
                // ë¹ˆ ì¤„ì€ ê·¸ëŒ€ë¡œ ì¶”ê°€
                lines.push('');
                return;
              }

              const words = paragraph.split(' ');
              let currentLine = words[0] || '';

              for (let i = 1; i < words.length; i++) {
                const word = words[i];
                const width = ctx.measureText(currentLine + ' ' + word).width;
                if (width < maxWidth) {
                  currentLine += ' ' + word;
                } else {
                  lines.push(currentLine);
                  currentLine = word;
                }
              }
              if (currentLine) {
                lines.push(currentLine);
              }
            });

            // ê° ì¤„ì— í…ìŠ¤íŠ¸ ê·¸ë¦¬ê¸°
            lines.forEach((line, index) => {
              const lineY = textY + (index - (lines.length - 1) / 2) * (textFontSize + 5);

              // í…ìŠ¤íŠ¸ ì™¸ê³½ì„  (ê·¸ë¦¼ì íš¨ê³¼)
              if (textStrokeWidth > 0) {
                ctx.strokeStyle = textStrokeColor;
                ctx.lineWidth = textStrokeWidth;
                ctx.strokeText(line, textX, lineY);
              }

              // í…ìŠ¤íŠ¸ ê·¸ë¦¬ê¸°
              ctx.fillStyle = textColor;
              ctx.fillText(line, textX, lineY);
            });
          }
        });

        // ë§í¬ í…ìŠ¤íŠ¸ ê·¸ë¦¬ê¸°
        links.forEach(link => {
          if (link.position && link.text) {
            const linkX = link.position.x;
            const linkY = link.position.y;

            // ë§í¬ë³„ ìŠ¤íƒ€ì¼ ì ìš©
            const linkStyle = link.style || {
              fontSize: 20,
              color: '#0066cc',
              strokeColor: '#000000',
              underline: true
            };

            const linkFontSize = linkStyle.fontSize || 20;
            const linkColor = linkStyle.color || '#0066cc';
            const linkStrokeColor = linkStyle.strokeColor || '#000000';
            const linkUnderline = linkStyle.underline !== undefined ? linkStyle.underline : true;

            // ë§í¬ í…ìŠ¤íŠ¸ ê·¸ë¦¬ê¸°
            ctx.font = `${linkFontSize}px ${fontFamily}`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // í…ìŠ¤íŠ¸ ì™¸ê³½ì„ 
            ctx.strokeStyle = linkStrokeColor;
            ctx.lineWidth = 3;
            ctx.strokeText(link.text, linkX, linkY);

            // ë§í¬ í…ìŠ¤íŠ¸
            ctx.fillStyle = linkColor;
            ctx.fillText(link.text, linkX, linkY);

            // ë§í¬ ë°‘ì¤„
            if (linkUnderline) {
              const textWidth = ctx.measureText(link.text).width;
              ctx.strokeStyle = linkColor;
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(linkX - textWidth / 2, linkY + linkFontSize / 2 + 3);
              ctx.lineTo(linkX + textWidth / 2, linkY + linkFontSize / 2 + 3);
              ctx.stroke();
            }
          }
        });

        // ìº”ë²„ìŠ¤ë¥¼ Blobìœ¼ë¡œ ë³€í™˜
        canvas.toBlob((blob) => {
          const fileName = imageFile.name || `processed-image-${Date.now()}.png`;
          const fileType = imageFile.type || 'image/png';

          const file = new File([blob], fileName, {
            type: fileType,
            lastModified: Date.now()
          });
          resolve(file);
        }, imageFile.type || 'image/png');
      };

      img.onerror = reject;
      img.src = URL.createObjectURL(imageFile);
    });
  };

  // í…ìŠ¤íŠ¸ ì¶”ê°€ ì²˜ë¦¬
  const handleAddTextToImage = async () => {
    console.log('handleAddTextToImage í˜¸ì¶œë¨');
    console.log('imageFile:', imageFile);
    console.log('mainTexts:', mainTexts);
    console.log('mainTexts ê¸¸ì´:', mainTexts.length);
    console.log('links ìƒíƒœ:', links);
    console.log('links ê¸¸ì´:', links.length);

    if (!imageFile || (mainTexts.length === 0 && links.length === 0)) {
      console.log('ì´ë¯¸ì§€ íŒŒì¼ì´ ì—†ê±°ë‚˜ ëŒ€í‘œê¸€ê³¼ ë§í¬ê°€ ëª¨ë‘ ì—†ìŒ');
      return;
    }

        try {
      const processedImage = await addTextToImage(imageFile, mainTexts, {
        fontSize: mainTextOptions.fontSize,
        color: mainTextOptions.color,
        strokeColor: mainTextOptions.strokeColor,
        position: mainTextOptions.position,
        customX: mainTextOptions.customX,
        customY: mainTextOptions.customY
      }, links); // ë§í¬ ë°°ì—´ ì „ë‹¬

      // ëŒ€í‘œê¸€ê³¼ ë§í¬ ì •ë³´ì™€ í•¨ê»˜ ê²°ê³¼ ë°˜í™˜
      const result = {
        imageFile: processedImage,
        mainTexts: mainTexts || [], // ëŒ€í‘œê¸€ ë°°ì—´ ì „ë‹¬
        links: links || [] // ë§í¬ ë°°ì—´ ì „ë‹¬
      };

      console.log('ImageTextModal - Sending result:', result);
      console.log('ImageTextModal - MainTexts in result:', result.mainTexts);
      console.log('ImageTextModal - Links in result:', result.links);
      console.log('ImageTextModal - MainTexts JSON:', JSON.stringify(result.mainTexts, null, 2));
      console.log('ImageTextModal - Links JSON:', JSON.stringify(result.links, null, 2));

      onConfirm(result);

      // ëª¨ë‹¬ ìƒíƒœ ì´ˆê¸°í™”
      setMainTexts([]);
      setLinks([]);
      setCurrentMainText({
        text: '',
        fontSize: 24,
        color: '#ffffff',
        strokeColor: '#000000',
        position: 'bottom',
        customX: null,
        customY: null,
        id: null
      });
      setCurrentLink({ url: '', text: '', position: null });
      setMainTextOptions({
        fontSize: 24,
        color: '#ffffff',
        strokeColor: '#000000',
        position: 'bottom',
        ...defaultOptions
      });
      setLinkOptions({
        fontSize: 20,
        color: '#0066cc',
        strokeColor: '#000000',
        underline: true,
        ...defaultOptions
      });
      setPreviewUrl('');
    } catch (error) {
      console.error('ì´ë¯¸ì§€ í…ìŠ¤íŠ¸ ì¶”ê°€ ì‹¤íŒ¨:', error);
    }
  };

  // ëª¨ë‹¬ ë‹«ê¸°
  const handleClose = () => {
    // ëª¨ë“  ìƒíƒœ ì´ˆê¸°í™”
    setMainTexts([]);
    setLinks([]);
    setCurrentMainText({
      text: '',
      fontSize: 24,
      color: '#ffffff',
      strokeColor: '#000000',
      position: 'bottom',
      customX: null,
      customY: null,
      id: null
    });
    setCurrentLink({ url: '', text: '', position: null });
    setMainTextOptions({
      fontSize: 24,
      color: '#ffffff',
      strokeColor: '#000000',
      position: 'bottom',
      ...defaultOptions
    });
    setLinkOptions({
      fontSize: 20,
      color: '#0066cc',
      strokeColor: '#000000',
      underline: true,
      ...defaultOptions
    });
    setPreviewUrl('');
    setIsDragging(false);
    setDraggedLinkId(null);
    setDragOffset({ x: 0, y: 0 });

    // ë¶€ëª¨ ì»´í¬ë„ŒíŠ¸ì— ë‹«ê¸° ì•Œë¦¼
    onClose();
  };

  if (!isOpen || !imageFile) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-white rounded-lg w-11/12 sm:w-5/6 md:w-4/5 lg:w-3/4 xl:w-2/3 max-w-6xl max-h-[90vh] overflow-hidden">
        {/* ëª¨ë‹¬ í—¤ë” */}
        <div className="flex items-center justify-between p-2 sm:p-3 md:p-4 border-b">
          <h3 className="text-sm sm:text-base md:text-lg font-semibold">ì´ë¯¸ì§€ì— í…ìŠ¤íŠ¸ ì¶”ê°€</h3>
          <button
            onClick={handleClose}
            className="text-gray-500 hover:text-gray-700"
          >
            <X className="w-6 h-6" />
          </button>
        </div>

        {/* ëª¨ë‹¬ ë‚´ìš© */}
        <div className="p-2 sm:p-3 md:p-4 max-h-[calc(90vh-120px)] overflow-auto">
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-4">
            {/* ì™¼ìª½: ì„¤ì • íŒ¨ë„ */}
            <div className="space-y-6">
              {/* ëŒ€í‘œê¸€ ì…ë ¥ */}
              <div className="bg-blue-50 p-4 rounded-lg border border-blue-200">
                <label className="block text-sm font-semibold text-blue-800 mb-2 flex items-center gap-2">
                  ğŸ“ ëŒ€í‘œê¸€ ì…ë ¥
                </label>
                <textarea
                  value={currentMainText.text}
                  onChange={(e) => setCurrentMainText(prev => ({ ...prev, text: e.target.value }))}
                  placeholder="ì´ë¯¸ì§€ì— ì¶”ê°€í•  ëŒ€í‘œê¸€ì„ ì…ë ¥í•˜ì„¸ìš” (ì„ íƒì‚¬í•­)"
                  className="w-full p-3 border border-blue-300 rounded-lg resize-none bg-white"
                  rows={3}
                />

                {/* ëŒ€í‘œê¸€ ìŠ¤íƒ€ì¼ ì˜µì…˜ */}
                <div className="grid grid-cols-2 gap-2 mt-3">
                  <div>
                    <label className="block text-xs text-blue-700 mb-1">í°íŠ¸ í¬ê¸°</label>
                    <input
                      type="range"
                      min="12"
                      max="72"
                      value={currentMainText.fontSize}
                      onChange={(e) => setCurrentMainText(prev => ({ ...prev, fontSize: parseInt(e.target.value) }))}
                      className="w-full"
                    />
                    <span className="text-xs text-blue-600">{currentMainText.fontSize}px</span>
                  </div>
                  <div>
                    <label className="block text-xs text-blue-700 mb-1">ìƒ‰ìƒ</label>
                    <input
                      type="color"
                      value={currentMainText.color}
                      onChange={(e) => setCurrentMainText(prev => ({ ...prev, color: e.target.value }))}
                      className="w-full h-8 border border-blue-300 rounded"
                    />
                  </div>
                </div>

                {/* ëŒ€í‘œê¸€ ìœ„ì¹˜ ì„¤ì • */}
                <div className="mt-3">
                  <label className="block text-xs text-blue-700 mb-1">ìœ„ì¹˜</label>
                  <select
                    value={currentMainText.position}
                    onChange={(e) => setCurrentMainText(prev => ({
                      ...prev,
                      position: e.target.value,
                      customX: null,
                      customY: null
                    }))}
                    className="w-full p-2 border border-blue-300 rounded text-sm"
                  >
                    <option value="top">ìƒë‹¨</option>
                    <option value="center">ì¤‘ì•™</option>
                    <option value="bottom">í•˜ë‹¨</option>
                    <option value="custom">ë“œë˜ê·¸ ìœ„ì¹˜</option>
                  </select>
                  {currentMainText.position === 'custom' && (
                    <p className="text-xs text-blue-600 mt-1">
                      ğŸ’¡ ëŒ€í‘œê¸€ì„ ì¶”ê°€í•œ í›„ ë¯¸ë¦¬ë³´ê¸°ì—ì„œ ë“œë˜ê·¸í•˜ì—¬ ìœ„ì¹˜ë¥¼ ì¡°ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
                    </p>
                  )}
                </div>

                <button
                  onClick={addMainText}
                  disabled={!currentMainText.text.trim()}
                  className={`w-full mt-3 px-3 py-2 rounded text-sm ${
                    !currentMainText.text.trim()
                      ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
                      : 'bg-blue-500 text-white hover:bg-blue-600'
                  }`}
                >
                  ëŒ€í‘œê¸€ ì¶”ê°€
                </button>

                {/* ì¶”ê°€ëœ ëŒ€í‘œê¸€ ëª©ë¡ */}
                {mainTexts.length > 0 && (
                  <div className="space-y-2 mt-4">
                    <h4 className="text-sm font-semibold text-blue-800 flex items-center gap-2">
                      âœ… ì¶”ê°€ëœ ëŒ€í‘œê¸€ ({mainTexts.length}ê°œ):
                    </h4>
                    {mainTexts.map((mainText, index) => (
                      <div key={mainText.id} className="flex items-center justify-between p-3 bg-white rounded-lg border border-blue-200 text-sm">
                        <div className="flex-1">
                          <div className="font-medium text-blue-800">{mainText.text}</div>
                          <div className="text-blue-600 text-xs">
                            í¬ê¸°: {mainText.fontSize}px | ìƒ‰ìƒ: {mainText.color}
                          </div>
                        </div>
                        <button
                          onClick={() => removeMainText(mainText.id)}
                          className="ml-2 px-2 py-1 bg-red-500 text-white rounded hover:bg-red-600 text-xs"
                        >
                          ì‚­ì œ
                        </button>
                      </div>
                    ))}
                  </div>
                )}

                <p className="text-xs text-blue-600 mt-2">
                  ëŒ€í‘œê¸€ì„ ì…ë ¥í•˜ì§€ ì•Šì•„ë„ ë§í¬ë§Œ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
                </p>
              </div>

              {/* ë§í¬ ê´€ë¦¬ */}
              <div className="bg-green-50 p-4 rounded-lg border border-green-200">
                <label className="block text-sm font-semibold text-green-800 mb-2 flex items-center gap-2">
                  <Link className="w-4 h-4" />
                  ğŸ”— ë§í¬ ì¶”ê°€
                </label>

                                {/* ë§í¬ ì…ë ¥ í¼ */}
                <div className="space-y-2 mb-3">
                  <input
                    type="text"
                    value={currentLink.url}
                    onChange={(e) => setCurrentLink(prev => ({ ...prev, url: e.target.value }))}
                    placeholder="ë§í¬ URLì„ ì…ë ¥í•˜ì„¸ìš” (ì˜ˆ: https://example.com)"
                    className={`w-full p-2 border rounded text-sm ${
                      currentLink.url && !isValidUrl(currentLink.url)
                        ? 'border-red-500 bg-red-50'
                        : 'border-gray-300'
                    }`}
                  />
                  {currentLink.url && !isValidUrl(currentLink.url) && (
                    <p className="text-xs text-red-600">ìœ íš¨í•œ URLì„ ì…ë ¥í•´ì£¼ì„¸ìš” (http:// ë˜ëŠ” https:// í¬í•¨)</p>
                  )}
                  <input
                    type="text"
                    value={currentLink.text}
                    onChange={(e) => setCurrentLink(prev => ({ ...prev, text: e.target.value }))}
                    placeholder="ë§í¬ í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”"
                    className="w-full p-2 border border-gray-300 rounded text-sm"
                  />

                  {/* ë§í¬ í…ìŠ¤íŠ¸ ë¯¸ë¦¬ë³´ê¸° */}
                  {currentLink.text && (
                    <div className="p-2 bg-gray-50 rounded border">
                      <p className="text-xs text-gray-600 mb-1">ë§í¬ í…ìŠ¤íŠ¸ ë¯¸ë¦¬ë³´ê¸°:</p>
                      <div
                        className="text-center"
                        style={{
                          fontSize: `${linkOptions.fontSize}px`,
                          color: linkOptions.color,
                          textShadow: `2px 2px 2px ${linkOptions.strokeColor}`,
                          textDecoration: linkOptions.underline ? 'underline' : 'none',
                          textDecorationColor: linkOptions.color
                        }}
                      >
                        {currentLink.text}
                      </div>
                    </div>
                  )}

                  <button
                    onClick={() => {
                      console.log('ë§í¬ ì¶”ê°€ ë²„íŠ¼ í´ë¦­ë¨');
                      addLink();
                    }}
                    disabled={!currentLink.url.trim() || !currentLink.text.trim() || !isValidUrl(currentLink.url)}
                    className={`w-full px-3 py-2 rounded text-sm ${
                      !currentLink.url.trim() || !currentLink.text.trim() || !isValidUrl(currentLink.url)
                        ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
                        : 'bg-blue-500 text-white hover:bg-blue-600'
                    }`}
                  >
                    ë§í¬ ì¶”ê°€
                  </button>
                </div>

                {/* ì¶”ê°€ëœ ë§í¬ ëª©ë¡ */}
                {links.length > 0 && (
                  <div className="space-y-2 mt-4">
                    <h4 className="text-sm font-semibold text-green-800 flex items-center gap-2">
                      âœ… ì¶”ê°€ëœ ë§í¬ ({links.length}ê°œ):
                    </h4>
                    {links.map((link, index) => (
                      <div key={link.id} className="flex items-center justify-between p-3 bg-white rounded-lg border border-green-200 text-sm">
                        <div className="flex-1">
                          <div className="font-medium text-green-800">{link.text}</div>
                          <div className="text-green-600 truncate text-xs">{link.url}</div>
                        </div>
                        <button
                          onClick={() => removeLink(link.id)}
                          className="ml-2 px-2 py-1 bg-red-500 text-white rounded hover:bg-red-600 text-xs"
                        >
                          ì‚­ì œ
                        </button>
                      </div>
                    ))}
                  </div>
                )}
              </div>

              {/* ê¸°ë³¸ ì„¤ì • (ìƒˆ ëŒ€í‘œê¸€ì˜ ê¸°ë³¸ê°’) */}
              <div className="bg-gray-50 p-4 rounded-lg border border-gray-200">
                <h4 className="text-sm font-medium text-gray-700 mb-3">âš™ï¸ ê¸°ë³¸ ì„¤ì •</h4>
                <p className="text-xs text-gray-600 mb-3">
                  ìƒˆë¡œ ì¶”ê°€í•  ëŒ€í‘œê¸€ì˜ ê¸°ë³¸ ìŠ¤íƒ€ì¼ì„ ì„¤ì •í•©ë‹ˆë‹¤.
                </p>

                {/* ê¸°ë³¸ í°íŠ¸ í¬ê¸° */}
                <div className="mb-3">
                  <label className="block text-xs text-gray-600 mb-1">ê¸°ë³¸ í°íŠ¸ í¬ê¸°</label>
                  <input
                    type="range"
                    min="12"
                    max="72"
                    value={mainTextOptions.fontSize}
                    onChange={(e) => setMainTextOptions(prev => ({ ...prev, fontSize: parseInt(e.target.value) }))}
                    className="w-full"
                  />
                  <span className="text-xs text-gray-500">{mainTextOptions.fontSize}px</span>
                </div>

                {/* ê¸°ë³¸ ìƒ‰ìƒ */}
                <div className="grid grid-cols-2 gap-2 mb-3">
                  <div>
                    <label className="block text-xs text-gray-600 mb-1">ê¸°ë³¸ ìƒ‰ìƒ</label>
                    <input
                      type="color"
                      value={mainTextOptions.color}
                      onChange={(e) => setMainTextOptions(prev => ({ ...prev, color: e.target.value }))}
                      className="w-full h-8 border border-gray-300 rounded"
                    />
                  </div>
                  <div>
                    <label className="block text-xs text-gray-600 mb-1">ê¸°ë³¸ ì™¸ê³½ì„ </label>
                    <input
                      type="color"
                      value={mainTextOptions.strokeColor}
                      onChange={(e) => setMainTextOptions(prev => ({ ...prev, strokeColor: e.target.value }))}
                      className="w-full h-8 border border-gray-300 rounded"
                    />
                  </div>
                </div>

                {/* ê¸°ë³¸ ìœ„ì¹˜ */}
                <div>
                  <label className="block text-xs text-gray-600 mb-1">ê¸°ë³¸ ìœ„ì¹˜</label>
                  <select
                    value={mainTextOptions.position}
                    onChange={(e) => setMainTextOptions(prev => ({
                      ...prev,
                      position: e.target.value
                    }))}
                    className="w-full p-2 border border-gray-300 rounded text-xs"
                  >
                    <option value="top">ìƒë‹¨</option>
                    <option value="center">ì¤‘ì•™</option>
                    <option value="bottom">í•˜ë‹¨</option>
                    <option value="custom">ë“œë˜ê·¸ ìœ„ì¹˜</option>
                  </select>
                </div>
              </div>

                {/* ë§í¬ ìŠ¤íƒ€ì¼ ì„¤ì • */}
                <div className="border-t pt-4">
                  <h4 className="text-sm font-medium text-gray-700 mb-3 flex items-center gap-2">
                    <Link className="w-4 h-4" />
                    ë§í¬ ìŠ¤íƒ€ì¼ ì„¤ì •
                  </h4>

                  {/* ë§í¬ í°íŠ¸ í¬ê¸° */}
                  <div className="mb-4">
                    <label className="block text-sm font-medium text-gray-700 mb-2">ë§í¬ í°íŠ¸ í¬ê¸°</label>
                    <input
                      type="range"
                      min="12"
                      max="48"
                      value={linkOptions.fontSize}
                      onChange={(e) => setLinkOptions(prev => ({ ...prev, fontSize: parseInt(e.target.value) }))}
                      className="w-full"
                    />
                    <span className="text-sm text-gray-600">{linkOptions.fontSize}px</span>
                  </div>

                  {/* ë§í¬ ìƒ‰ìƒ ì„ íƒ */}
                  <div className="grid grid-cols-2 gap-4 mb-4">
                    {/* ë§í¬ í…ìŠ¤íŠ¸ ìƒ‰ìƒ */}
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-2">ë§í¬ ìƒ‰ìƒ</label>
                      <input
                        type="color"
                        value={linkOptions.color}
                        onChange={(e) => setLinkOptions(prev => ({ ...prev, color: e.target.value }))}
                        className="w-full h-10 border border-gray-300 rounded-lg"
                      />
                    </div>

                    {/* ë§í¬ ì™¸ê³½ì„  ìƒ‰ìƒ */}
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-2">ì™¸ê³½ì„  ìƒ‰ìƒ</label>
                      <input
                        type="color"
                        value={linkOptions.strokeColor}
                        onChange={(e) => setLinkOptions(prev => ({ ...prev, strokeColor: e.target.value }))}
                        className="w-full h-10 border border-gray-300 rounded-lg"
                      />
                    </div>
                  </div>

                  {/* ë§í¬ ë°‘ì¤„ */}
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-2">ë°‘ì¤„ í‘œì‹œ</label>
                    <div className="flex items-center">
                      <input
                        type="checkbox"
                        checked={linkOptions.underline}
                        onChange={(e) => setLinkOptions(prev => ({ ...prev, underline: e.target.checked }))}
                        className="mr-2"
                      />
                      <span className="text-sm text-gray-600">ë°‘ì¤„ í‘œì‹œ</span>
                    </div>
                  </div>
                </div>
              </div>
            </div>

            {/* ì˜¤ë¥¸ìª½: ë¯¸ë¦¬ë³´ê¸° */}
            <div className="space-y-4">
              <h4 className="text-sm font-medium text-gray-700">ì‹¤ì‹œê°„ ë¯¸ë¦¬ë³´ê¸°</h4>
              <div
                ref={previewContainerRef}
                className="flex justify-center relative"
                onMouseDown={handleMouseDown}
                onMouseMove={handleMouseMove}
                onMouseUp={handleMouseUp}
                onMouseLeave={handleMouseUp}
                style={{ cursor: (mainTextOptions.position === 'custom' && currentMainText.text.trim()) || links.length > 0 ? 'grab' : 'default' }}
              >
                {previewUrl ? (
                  <img
                    src={previewUrl}
                    alt="ë¯¸ë¦¬ë³´ê¸°"
                    className="max-w-full max-h-64 object-contain rounded-lg border shadow-lg"
                    style={{
                      cursor: (mainTextOptions.position === 'custom' && currentMainText.text.trim()) || links.length > 0 ? 'grab' : 'default',
                      userSelect: 'none'
                    }}
                  />
                ) : (
                  <img
                    src={URL.createObjectURL(imageFile)}
                    alt="ì›ë³¸ ì´ë¯¸ì§€"
                    className="max-w-full max-h-64 object-contain rounded-lg border"
                    style={{
                      cursor: links.length > 0 ? 'grab' : 'default',
                      userSelect: 'none'
                    }}
                  />
                )}
              </div>
              <div className="text-xs text-gray-500 text-center">
                {mainTexts.length > 0 ?
                  (mainTextOptions.position === 'custom' ?
                    'ğŸ“ ëŒ€í‘œê¸€ì„ ë“œë˜ê·¸í•˜ì—¬ ìœ„ì¹˜ ì¡°ì •' :
                    'ğŸ“ ëŒ€í‘œê¸€ì´ ì¶”ê°€ëœ ë¯¸ë¦¬ë³´ê¸°') :
                  links.length > 0 ?
                    'ğŸ”— ë§í¬ë§Œ ì¶”ê°€ëœ ë¯¸ë¦¬ë³´ê¸°' :
                    'ì›ë³¸ ì´ë¯¸ì§€'}
                {links.length > 0 && (
                  <div className="mt-1 text-green-600">
                    ğŸ”— {links.length}ê°œì˜ ë§í¬ê°€ í¬í•¨ë¨ (ë“œë˜ê·¸ë¡œ ìœ„ì¹˜ ì¡°ì • ê°€ëŠ¥)
                  </div>
                )}
              </div>
            </div>
          </div>
        </div>

        {/* ëª¨ë‹¬ í‘¸í„° */}
        <div className="flex items-center justify-between p-2 sm:p-3 md:p-4 border-t bg-gray-50">
          <div className="text-sm text-gray-600">
            {mainTexts.length > 0 ? (
              mainTextOptions.position === 'custom' ?
                'ğŸ“ ëŒ€í‘œê¸€ì„ ë“œë˜ê·¸í•˜ì—¬ ì›í•˜ëŠ” ìœ„ì¹˜ì— ë°°ì¹˜í•˜ì„¸ìš”.' :
                'ğŸ“ ëŒ€í‘œê¸€ì„ ì…ë ¥í•˜ë©´ ì‹¤ì‹œê°„ìœ¼ë¡œ ë¯¸ë¦¬ë³´ê¸°ê°€ ì—…ë°ì´íŠ¸ë©ë‹ˆë‹¤.'
            ) : links.length > 0 ? (
              'ğŸ”— ë§í¬ë§Œ ì¶”ê°€ëœ ìƒíƒœì…ë‹ˆë‹¤. ëŒ€í‘œê¸€ì„ ì…ë ¥í•˜ê±°ë‚˜ ë§í¬ë¥¼ ë” ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.'
            ) : (
              'ğŸ“ ëŒ€í‘œê¸€ì„ ì…ë ¥í•˜ê±°ë‚˜ ğŸ”— ë§í¬ë¥¼ ì¶”ê°€í•´ë³´ì„¸ìš”.'
            )}
            {links.length > 0 && (
              <span className="ml-2 text-green-600">ğŸ”— {links.length}ê°œì˜ ë§í¬ê°€ í¬í•¨ë©ë‹ˆë‹¤.</span>
            )}
          </div>
          <div className="flex gap-1 sm:gap-2 flex-shrink-0">
            <button
              onClick={handleClose}
              className="px-2 sm:px-3 md:px-4 py-1 sm:py-2 bg-gray-500 text-white rounded hover:bg-gray-600 text-xs sm:text-sm"
            >
              ì·¨ì†Œ
            </button>
            <button
              onClick={handleAddTextToImage}
              disabled={mainTexts.length === 0 && links.length === 0}
              className="px-2 sm:px-3 md:px-4 py-1 sm:py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed text-xs sm:text-sm"
            >
              {mainTexts.length > 0 ? 'í…ìŠ¤íŠ¸ ì¶”ê°€' : links.length > 0 ? 'ë§í¬ ì¶”ê°€' : 'í…ìŠ¤íŠ¸ ì¶”ê°€'}
            </button>
          </div>
        </div>
      </div>

      {/* ìˆ¨ê²¨ì§„ ìº”ë²„ìŠ¤ (ë¯¸ë¦¬ë³´ê¸° ìƒì„±ìš©) */}
      <canvas ref={canvasRef} style={{ display: 'none' }} />
    </div>
  );
}
